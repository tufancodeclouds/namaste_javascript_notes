<!DOCTYPE html>
<html>
  <head>
    <title>Namaste JavaScript</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link type="text/css" rel="stylesheet" href="./css/style.css" />
    <link type="text/css" rel="stylesheet" href="./css/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="./css/hljs-github.min.css"/>
  </head>
<body><h2 id="title-namaste-javascript"><a class="header-link" href="#title-namaste-javascript"></a>Namaste JavaScript</h2>
<br> 

<h1 id="episode-1--execution-context">Episode 1 : Execution Context</h1>
<ul class="list">
<li><p>জাভাস্ক্রিপ্টে সব কিছু Execution Context এর ভিতরে ঘটে। কল্পনা করো একটি সিল করা কন্টেইনার, যার ভিতরে JS রান করে। এটি একটি বিমূর্ত ধারণা যা বর্তমান কোড যে পরিবেশে চলছে তার তথ্য ধরে রাখে। <img src="./images/execution-context.jpg" alt="Execution Context" title="Execution Context"></p></li>
<li><p>এই কন্টেইনারে প্রথম উপাদানটি হল <strong>মেমোরি কম্পোনেন্ট</strong> এবং দ্বিতীয়টি <strong>কোড কম্পোনেন্ট</strong></p></li>
<li><p>মেমোরি কম্পোনেন্টে সব ভেরিয়েবল এবং ফাংশন key-value আকারে থাকে। এটিকে <strong>Variable Environment</strong> ও বলা হয়।</p></li>
<li><p>কোড কম্পোনেন্ট এমন একটি জায়গা যেখানে কোড এক লাইনে এক্সিকিউট হয়। এটিকে <strong>Thread of Execution</strong> ও বলা হয়।</p></li>
<li><p>JS একটি <strong>synchronous</strong>, <strong>single-threaded</strong> ভাষা।</p>
<ul class="list">
<li>Synchronous:- নির্দিষ্ট অনুক্রমে একটির পর একটি চলে।</li>
<li>Single-threaded:- এক সময়ে একটি কমান্ড চলে।</li>
</ul>
</li>
</ul>
<hr>

<p>লাইভ দেখুন ইউটিউবে নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=ZvbzSrg0afE" target="_blank"><img src="https://img.youtube.com/vi/ZvbzSrg0afE/0.jpg" width="750"
alt="Execution Context Youtube Link"/></a></p>

<h1 id="episode-2--how-js-is-executed--call-stack">Episode 2 : How JS is executed & Call Stack</h1>
<ul class="list">
<li><p>যখন একটি JS প্রোগ্রাম চালানো হয়, তখন একটি <strong>Global Execution Context</strong> তৈরি হয়।</p></li>
<li><p>Execution Context দুটি ধাপে তৈরি হয়।</p>
<ul class="list">
<li>Memory creation phase - JS ভেরিয়েবল এবং ফাংশন গুলোর জন্য মেমোরি বরাদ্দ করে।</li>
<li>Code execution phase</li>
</ul>
</li>
<li><p>নিচের উদাহরণটি এবং এর এক্সিকিউশন ধাপগুলি বিবেচনা করি:</p></li>
</ul>

<pre class="hljs"><code><span class="hljs-keyword">var</span> n = <span class="hljs-number">2</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">num</span>) </span>{
  <span class="hljs-keyword">var</span> ans = num * num;
  <span class="hljs-keyword">return</span> ans;
}
<span class="hljs-keyword">var</span> square2 = square(n);
<span class="hljs-keyword">var</span> square4 = square(<span class="hljs-number">4</span>);</code></pre>
<p>প্রথমে JS <strong>Memory Creation Phase</strong> চালায়। প্রথম লাইনে 'n' এর জন্য মেমোরি বরাদ্দ করে এবং 'undefined' রাখে। তারপর ফাংশনের জন্য পুরো কোড মেমোরিতে রাখে। একইভাবে 'square2' এবং 'square4' এর জন্যও মেমোরি বরাদ্দ করে এবং তাতে 'undefined' রাখা হয়।</p>

<p><img src="./images/phase1.jpg" alt="Execution Context Phase 1" title="Execution Context"></p>

<p>এরপর <strong>Code Execution Phase</strong> এ যায়, যেখানে প্রতিটি লাইন এক্সিকিউট হয়।</p>

<p>যখন square(n) কল করা হয়, তখন একটি নতুন Execution Context তৈরি হয়। সেখানে আবার মেমোরি ফেজে num ও ans এর জন্য undefined রাখা হয়। পরবর্তীতে তাদের মান নির্ধারণ হয়। তারপর return এর মাধ্যমে নিয়ন্ত্রণ আগের জায়গায় ফিরে যায়।</p>

<p><img src="./images/phase2.jpg" alt="Execution Context Phase 2" title="Execution Context"></p>

<p>return হলে function execution context মুছে যায়। square4 এর ক্ষেত্রেও একই প্রক্রিয়া চলে। সব শেষে Global Execution Context মুছে যায়।</p>

<p><img src="./images/final_execution_context.jpg" alt="Execution Context Phase 2" title="Execution Context"></p>

<ul class="list">
<li><p>Javascript <strong>Call Stack</strong> এর মাধ্যমে Execution Context তৈরি ও মুছে ফেলার কাজ করে।</p></li>
<li><p>Call Stack একাধিক function call এর ট্র্যাক রাখে।</p></li>
<li><p>Call Stack Execution Context গুলোর অনুক্রম ধরে রাখে। একে Program Stack, Control Stack, Runtime Stack, Machine Stack, Execution Context Stack ইত্যাদি বলা হয়।</p></li>
</ul>

<hr>

<p>লাইভ দেখুন ইউটিউবে নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=iLWTnMzWtj4" target="_blank"><img src="https://img.youtube.com/vi/iLWTnMzWtj4/0.jpg" width="750"
alt="How JS is executed & Call Stack Youtube Link"/></a></p>
<br>

<hr>

<br>

<h1 id="episode-3--hoisting-in-javascript-variables--functions"><a class="header-link" href="#episode-3--hoisting-in-javascript-variables--functions"></a>Episode 3 : Hoisting in JavaScript (variables &amp; functions)</h1>
<ul class="list">
<li>নিচের কোডটি এবং এর ব্যাখ্যা লক্ষ্য করো:</li>
</ul>
<pre class="hljs"><code>getName(); <span class="hljs-comment">// Namaste Javascript</span>
<span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">var</span> x = <span class="hljs-number">7</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Namaste Javascript&quot;</span>);
}</code></pre>
<ul class="list">
<li><p>অন্যান্য অনেক প্রোগ্রামিং ভাষায় এটি সরাসরি একটি ভুল (error) হতো, কারণ কোনো কিছুকে তৈরি (define) করার আগেই এক্সেস করা সাধারণত সম্ভব নয়। কিন্তু JavaScript-এ, আমরা জানি যে মেমোরি তৈরি হওয়ার ধাপে (memory creation phase) এটি ভ্যারিয়েবলকে `undefined` দিয়ে ইনিশিয়ালাইজ করে এবং ফাংশনের কনটেন্ট মেমোরিতে রেখে দেয়। এরপর এক্সিকিউশন ধাপে যেটা বলা হয় সেটাই চালানো হয়। এখানে যেহেতু কোডটি লাইন বাই লাইন চলে এবং কম্পাইল করে নয়, তাই এটি `undefined` প্রিন্ট করবে এবং কোনো ত্রুটি দিবে না। তবে যদি `var x = 7;` লাইনটি সরিয়ে দেওয়া হয়, তাহলে এটি `Uncaught ReferenceError: x is not defined` এরর দিবে।</p>
</li>
<li><p><strong>Hoisting</strong> একটি ধারণা যা আমাদেরকে ভ্যারিয়েবল এবং ফাংশনের মান তাদের ইনিশিয়ালাইজ বা অ্যাসাইন করার আগেই বের করে আনার সুযোগ দেয় এবং এটি সম্ভব হয় Execution Context-এর প্রথম ধাপ (memory creation phase) এর কারণে।</p>
</li>
<li><p>আগের লেকচারে আমরা দেখেছি যে Execution Context দুইটি ধাপে তৈরি হয়, তাই কোড এক্সিকিউশন হওয়ার আগেই মেমোরি তৈরি হয়। ভ্যারিয়েবলের ক্ষেত্রে এটি `undefined` দিয়ে ইনিশিয়ালাইজ হয়, আর ফাংশনের ক্ষেত্রে পুরো ফাংশন কোডটি মেমোরিতে রাখা হয়। উদাহরণস্বরূপ:</p>
</li>
</ul>

<pre class="hljs"><code>getName(); <span class="hljs-comment">// Namaste JavaScript</span>
<span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// Uncaught Reference: x is not defined.</span>
<span class="hljs-built_in">console</span>.log(getName); <span class="hljs-comment">// f getName(){ console.log(&quot;Namaste JavaScript); }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Namaste JavaScript&quot;</span>);
}</code></pre>
<ul class="list">
<li>এখন চলো একটু ভিন্ন একটি উদাহরণ দেখি এবং এর আউটপুট বোঝার চেষ্টা করি।</li>
</ul>
<pre class="hljs"><code>getName(); <span class="hljs-comment">// Uncaught TypeError: getName is not a function</span>
<span class="hljs-built_in">console</span>.log(getName);
<span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Namaste JavaScript&quot;</span>);
};
<span class="hljs-comment">// কোডটি চলবে না কারণ প্রথম লাইনেই টাইপ এরর চলে আসবে।</span></code></pre>
<hr>

<p>লাইভ দেখো ইউটিউবে নিচের লিংক থেকে:</p>
<p><a href="https://www.youtube.com/watch?v=Fnlnw8uY6jo&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/Fnlnw8uY6jo/0.jpg" width="750"
alt="Hoisting Youtube Link"/></a></p>
<br>

<hr>

<br>

<h1 id="episode-4--functions-and-variable-environments"><a class="header-link" href="#episode-4--functions-and-variable-environments"></a>Episode 4 : Functions and Variable Environments</h1>
<pre class="hljs"><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;
a();
b(); <span class="hljs-comment">// আমরা ফাংশনগুলো ডিফাইন করার আগেই কল করছি। এটি ঠিকভাবে কাজ করবে, যেমন Hoisting এ দেখা গেছে।</span>
<span class="hljs-built_in">console</span>.log(x);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// আলাদা execution context হওয়ায় এটি লোকাল স্কোপ</span>
  <span class="hljs-built_in">console</span>.log(x);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">100</span>;
  <span class="hljs-built_in">console</span>.log(x);
}</code></pre>
<p>আউটপুটঃ</p>
<blockquote>
<p>10</p>
</blockquote>
<blockquote>
<p>100</p>
</blockquote>
<blockquote>
<p>1</p>
</blockquote>

<h2 id="code-flow-in-terms-of-execution-context"><a class="header-link" href="#code-flow-in-terms-of-execution-context"></a>Execution Context অনুযায়ী কোডের প্রবাহ</h2>
<ul class="list">
<li>গ্লোবাল এক্সিকিউশন কনটেক্সট (GEC) তৈরি হয় (একটি বড় বাক্স, যার মধ্যে মেমোরি ও কোড অংশ থাকে)। একই সাথে GEC কল স্ট্যাকে ঢুকে যায়।</li>
</ul>
<blockquote>
<p>Call Stack : GEC</p>
</blockquote>
<ul class="list">
<li><p>GEC-এর প্রথম ধাপে (মেমোরি ফেজে), ভ্যারিয়েবল x: undefined হয় এবং a ও b ফাংশনগুলোর পুরো কোড মেমোরিতে রাখা হয়।</p></li>
<li><p>GEC-এর দ্বিতীয় ধাপে (এক্সিকিউশন ফেজে), যখন ফাংশন কল হয়, তখন একটি নতুন লোকাল এক্সিকিউশন কনটেক্সট তৈরি হয়। প্রথমে x = 1 গ্লোবাল x-এ অ্যাসাইন হয়, তারপর a() কল হয়, তাই GEC-এর কোড অংশে একটি লোকাল EC তৈরি হয়।</p></li>
</ul>
<blockquote>
<p>Call Stack: [GEC, a()]</p>
</blockquote>
<ul class="list">
<li>a() এর লোকাল EC-তে একটি আলাদা x তৈরি হয় যা প্রথমে undefined এবং পরে 10 অ্যাসাইন হয়ে কনসোলে প্রিন্ট হয়। তারপর কোড শেষ হলে a() এর EC কল স্ট্যাক এবং GEC থেকে মুছে যায়।</li>
</ul>
<blockquote>
<p>Call Stack: GEC</p>
</blockquote>
<ul class="list">
<li>এরপর কার্সর b() ফাংশন কলে যায়। একই ধাপ আবার হয়।</li>
</ul>
<blockquote>
<p>Call Stack :[GEC, b()] → GEC (console.log-এ 100 প্রিন্ট হওয়ার পর আবার GEC এ ফিরে আসে)</p>
</blockquote>
<ul class="list">
<li><p>সবশেষে GEC-ও মুছে যায় এবং কল স্ট্যাক খালি হয়ে যায়। প্রোগ্রাম শেষ।</p></li>
<li><p>রেফারেন্সঃ</p></li>
</ul>
<p class="img-container"><img src="./images/function.jpg" alt="Execution Context Phase 1" title="Execution Context"></p>
<hr>

<p>লাইভ দেখো ইউটিউবে নিচের লিংক থেকে:</p>
<p><a href="https://www.youtube.com/watch?v=gSDncyuGw0s&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/gSDncyuGw0s/0.jpg" width="750"
alt="Functions and Variable Environments Youtube Link"/></a></p>
<br>

<hr>

<br>

<h1 id="episode-5--shortest-js-program-window--this-keyword"><a class="header-link" href="#episode-5--shortest-js-program-window--this-keyword"></a>Episode 5 : Shortest JS Program, window &amp; this keyword</h1>
<ul class="list">
<li><p>সবচেয়ে ছোট JS প্রোগ্রাম হলো খালি একটি ফাইল। কারণ এমনকি তখনও JS ইঞ্জিন অনেক কিছু করে। আগের মতোই, এখানে GEC তৈরি হয়, যার মধ্যে মেমোরি স্পেস ও এক্সিকিউশন কনটেক্সট থাকে।</p></li>
<li><p>JS ইঞ্জিন একটি জিনিস তৈরি করে যাকে বলা হয় '<strong>window</strong>'। এটি একটি অবজেক্ট যা গ্লোবাল স্কোপে তৈরি হয়। এতে অনেক ফাংশন ও ভ্যারিয়েবল থাকে যা প্রোগ্রামের যেকোনো জায়গা থেকে অ্যাক্সেস করা যায়। JS ইঞ্জিন একটি <strong>this</strong> কিওয়ার্ডও তৈরি করে, যা গ্লোবাল লেভেলে <strong>window object</strong>-এর দিকে ইঙ্গিত করে। তাই সংক্ষেপে বললে, GEC ছাড়াও একটি গ্লোবাল অবজেক্ট (window) এবং একটি this ভ্যারিয়েবল তৈরি হয়।</p></li>
<li><p>ভিন্ন JS ইঞ্জিনে গ্লোবাল অবজেক্টের নাম আলাদা হয়। যেমন ব্রাউজারে এটি window, আর Node.js-এ অন্য কিছু। গ্লোবাল লেভেলে, this === window হয়।</p></li>
<li><p>যদি আমরা গ্লোবাল স্কোপে কোনো ভ্যারিয়েবল তৈরি করি, তবে তা গ্লোবাল অবজেক্টের সাথে যুক্ত হয়ে যায়।</p></li>
</ul>

<p>উদাহরণ (eg):</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;
<span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.x); <span class="hljs-comment">// 10</span></code></pre>
<hr>

<p>নিচে ইউটিউবে লাইভ দেখো:</p>
<p><a href="https://www.youtube.com/watch?v=QCRpVw2KXf8&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/QCRpVw2KXf8/0.jpg" width="750"
alt="Shortest JS Program, window & this keyword Youtube Link"/></a></p>
<br>

<hr>

<br>

<h1 id="episode-6--undefined-vs-not-defined-in-js"><a class="header-link" href="#episode-6--undefined-vs-not-defined-in-js"></a>Episode 6 : undefined vs not defined in JS</h1>
<ul class="list">
<li><p>প্রথম ধাপে (মেমোরি বরাদ্দ) JS প্রতিটি ভ্যারিয়েবলকে একটি প্লেসহোল্ডার হিসেবে <strong>undefined</strong> মান দিয়ে ইনিশিয়ালাইজ করে।</p>
</li>
<li><p><strong>undefined</strong> তখন হয় যখন ভ্যারিয়েল্ড ভ্যারিয়েবল ডিক্লেয়ার করা হয় কিন্তু তাতে কোনো মান দেওয়া হয়নি।</p>
</li>
<li><p>যদি কোনো অবজেক্ট বা ভ্যারিয়েবল মেমোরি বরাদ্দ পর্যায়ে ডিক্লেয়ার না করা থাকে এবং এক্সেস করার চেষ্টা করা হয়, তবে সেটি <strong>Not defined</strong> হবে।</p>
</li>
<li><p>Not Defined ≠ Undefined</p>
</li>
</ul>
<blockquote>
<p>যখন ভ্যারিয়েবলটি ডিক্লেয়ার করা হয় কিন্তু মান দেওয়া হয়নি, তখন তার বর্তমান মান হয় <strong>undefined</strong>। কিন্তু যখন ভ্যারিয়েবলটি ডিক্লেয়ার করা হয় না, তবুও এটি কোডে কল করা হয়, তখন সেটি হয় <strong>not defined</strong>।</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">var</span> x = <span class="hljs-number">25</span>;
<span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 25</span>
<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span></code></pre>
<ul class="list">
<li>JS একটি <strong>loosely typed / weakly typed</strong> ভাষা। এটি ভ্যারিয়েবলগুলিকে কোনো নির্দিষ্ট ডেটাটাইপের সাথে আবদ্ধ করে না। আমরা যেমন বলতে পারি <em>var a = 5</em>, পরে সেটি boolean এ পরিবর্তন করতে পারি যেমন <em>a = true</em> বা string এ যেমন <em>a = 'hello'</em>।</li>
<li><strong>কখনো</strong> নিজে থেকে কোনো ভ্যারিয়েবলে <em>undefined</em> অ্যাসাইন করো না। এটি নিজ থেকেই ঘটতে দাও।</li>
</ul>
<hr>

<p>নিচে ইউটিউবে লাইভ দেখো:</p>
<p><a href="https://www.youtube.com/watch?v=B7iF6G3EyIk&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/B7iF6G3EyIk/0.jpg" width="750"
alt="undefined vs not defined in JS Youtube Link"/></a></p>
<br>

<hr>

<br>

<h1 id="episode-7--the-scope-chain-scope--lexical-environment"><a class="header-link" href="#episode-7--the-scope-chain-scope--lexical-environment"></a>Episode 7 : The Scope Chain, Scope &amp; Lexical Environment</h1>
<ul class="list">
<li><p>জাভাস্ক্রিপ্টে <strong>Scope</strong> সরাসরি সম্পর্কিত হয় <strong>Lexical Environment</strong>-এর সাথে।</p>
</li>
<li><p>নিচের উদাহরণগুলো লক্ষ্য করো:</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// CASE 1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 10</span>
  <span class="hljs-comment">// undefined প্রিন্ট না করে 10 প্রিন্ট হয়; অর্থাৎ a() ফাংশন global scope এর b-কে এক্সেস করতে পারে।</span>
}
<span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;
a();</code></pre>
<pre class="hljs"><code><span class="hljs-comment">// CASE 2</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
  c();
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 10</span>
  }
}
<span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;
a();</code></pre>
<pre class="hljs"><code><span class="hljs-comment">// CASE 3</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
  c();
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">100</span>;
    <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 100</span>
  }
}
<span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;
a();</code></pre>
<pre class="hljs"><code><span class="hljs-comment">// CASE 4</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;
  c();
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 10</span>
  }
}
a();
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// Error, Not Defined</span></code></pre>
<ul class="list">
<li>এখন প্রতিটি কেসের আউটপুট বোঝার চেষ্টা করি। <ul class="list">
<li>**Case 1**: a() ফাংশন global scope-এ থাকা b এক্সেস করতে পারে।</li>
<li>**Case 2**: 10 প্রিন্ট হয়—এটি দেখায় nested function-এও global scope-এর ভ্যারিয়েবল এক্সেস করা যায়।</li>
<li>**Case 3**: 100 প্রিন্ট হয়—মানে একই নামের local ভ্যারিয়েবল global-কে অগ্রাধিকার দিচ্ছে।</li>
<li>**Case 4**: একটি ফাংশন global variable এক্সেস করতে পারে, কিন্তু global execution context কোনো local variable এক্সেস করতে পারে না।</li>
<pre class="prettyprint">ইন এক্সিকিউশন কনটেক্সট মত:  
call_stack = [GEC, a(), c()]  
প্রত্যেক context-এর মেমোরি বিভাগ:  
c() = [[lexical environment pointer pointing to a()]]  
a() = [b:10, c:{}, [লেক্সিক্যাল এনভায়রনমেন্ট পয়েন্টার pointing to GEC]]  
GEC = [a:{}, [lexical_environment pointer pointing to null]]</pre>
<img src="./images/lexical.jpg" alt="Lexical Scope Explaination" title="Lexical Scope">
<img src="./images/lexical2.jpg" alt="Lexical Scope Explaination" title="Lexical Scope"></li>
</ul>
</li>
</ul>
<br>

<ul class="list">
<li><p>সুতরাং, <strong>Lexical Environment</strong> = লোকাল মেমোরি + তার parent-এর লেক্সিক্যাল এনভায়রনমেন্ট। অর্থাৎ, লেক্সিক্যাল এনভায়রনমেন্ট হলো লোকাল মেমোরি এবং parent-এ থাকা লেক্সিক্যাল এনভায়রনমেন্টের সমন্বয়।</p>
</li>
<li><p><strong>Lexical</strong>: ক্রমানুক্রম বা hierarchy-তে অবস্থিত।</p>
</li>
<li><p>যখনই একটি Execution Context তৈরি হয়, একটি Lexical Environment (LE) ও তৈরি হয় এবং তা মেমোরি স্পেসে local Execution Context-এর সঙ্গে রেফারেন্স করা হয়।</p>
</li>
<li><p>parent থেকে মান বের করে একে একে চেক করা, এই প্রক্রিয়াকে বলা হয় scope chain বা Lexical environment chain।</p>
</li>
<li><pre class="prettyprint">function a() {
  function c() {
    // এখানে লজিক
  }
  c(); // c হলো lexically a-এর ভিতরে
} // a lexically global execution-এর ভিতরে</pre>
</li>
<li><p>Lexical বা Static scope বলতে এক্সেসযোগ্যতা বুঝায় কোডের physical অবস্থানের ভিত্তিতে—যেমন কোনও ভ্যারিয়েবল বা ফাংশন কোথায় ডিক্লেয়ার করা হয়েছে তার উপর ভিত্তি করে।</p>
<pre class="prettyprint">Global {
    Outer {
        Inner
    }
}
// Inner থাকে Outer-এর লেক্সিক্যাল স্কোপ দ্বারা আবৃত</pre>
</li>
<li><p><strong>TLDR</strong>; একটি inner function তার outer function-এর ভ্যারিয়েবল এক্সেস করতে পারে, এমনকি inner function গভীরভাবে nested থাকলেও। অন্য қандай পরিস্থিতিতে, কোনো function তার স্কোপের বাইরে থাকা ভ্যারিয়েবল এক্সেস করতে পারে না।</p>
</li>
</ul>
<hr>

<p>নিচে ইউটিউবে লাইভ দেখো:</p>
<p><a href="https://www.youtube.com/watch?v=uH-tVP8MUs8&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/uH-tVP8MUs8/0.jpg" width="750"
alt="The Scope Chain, Scope & Lexical Environment Youtube Link"/></a></p>
<br>

<hr>

<br>

<h1 id="episode-8--let--const-in-js-temporal-dead-zone"><a class="header-link" href="#episode-8--let--const-in-js-temporal-dead-zone"></a>Episode 8 : let &amp; const in JS, Temporal Dead Zone</h1>
<ul class="list">
<li><p>let এবং const ঘোষণা (declaration) হচ্ছে hoisted, তবে এটি <strong>var</strong>-এর থেকে ভিন্ন।</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// ReferenceError: Cannot access 'a' before initialization</span>
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// আশা অনুযায়ী undefined প্রিন্ট হয়</span>
<span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;
<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 10</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-number">15</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.a); <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.b); <span class="hljs-comment">// 15</span></code></pre>
<p>লাগছে let হচ্ছে না hoisted, **কিন্তু এটি হয়** — আসল ব্যাপার বুঝি</p>
<ul class="list">
<li><p>দুটো হতে পারে— a এবং b আসলে hoisting স্টেজ-এই <em>undefined</em> হিসেবে ইনিশিয়ালাইজ হয়। কিন্তু var <strong>b</strong> গ্লোবাল স্টোরেজে যায়, আর <strong>a</strong> একটি আলাদা মেমোরি অবজেক্টে থেকে যেখানে সেটি অ্যাক্সেস করা যায় কেবল তখনই, যখন প্রথমে মান দেওয়া হয়—অর্থাৎ, 'a' তখনই প্রবেশযোগ্য হয়। তাই এটি error দেয়।</p></li>
</ul>
<br>

<ul class="list">
<li><p><strong>Temporal Dead Zone</strong> (TDZ): সময়কাল যখন থেকে let ভ্যারিয়েবলটি hoisted হয়েছে, কিন্তু তা কোনো মান পাইনি।</p>
<ul class="list">
<li>তাই "let a = 10" এর আগ পর্যন্ত যে কোনো লাইন ‘a’-এর TDZ।</li>
<li>a গ্লোবালে অ্যাক্সেসযোগ্য নয়, তাই তা <em>window/this</em> থেকেও অ্যাক্সেসযোগ্য নয়। window.b বা this.b → 15; কিন্তু window.a বা this.a → undefined, যেমন window.x → undefined (x কোনো জায়গায় ডিক্লেয়ার হয়নি)।</li>
</ul>
</li>
<li><p><strong>Reference Error</strong> ঘটে যখন ভ্যারিয়েবলগুলো Temporal Dead Zone-এ থাকে।</p></li>
<li><p><strong>Syntax Error</strong> এমন একটি error যা একটি লাইন কোডও চালাতে দেয় না।</p></li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;
<span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span>;  <span class="hljs-comment">// এই কোড upfront rejected হয় as SyntaxError. (duplicate declaration)</span>
------------------
<span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;
<span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>; <span class="hljs-comment">// এই কোডও upfront rejected হয় as SyntaxError. (একই স্কোপে একই নাম ব্যবহার করা যাবে না)</span></code></pre>
<ul class="list">
<li><strong>Let</strong> হল <strong>var</strong>-এর একটি কঠোর সংস্করণ। আবার <strong>const</strong> let-এর চেয়ে আরও কঠোর।</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">let</span> a;
a = <span class="hljs-number">10</span>;
<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 10. এখানে declaration এবং assignment ভিন্ন লাইনে হয়েছে।</span>
------------------
<span class="hljs-keyword">const</span> b;
b = <span class="hljs-number">10</span>;
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// SyntaxError: Missing initializer in const declaration. (এই ধরনের declaration const-এ কাজ করবে না। const b = 10 হলে চলে)</span>
------------------
<span class="hljs-keyword">const</span> b = <span class="hljs-number">100</span>;
b = <span class="hljs-number">1000</span>; <span class="hljs-comment">// এটি আমাদের TypeError: Assignment to constant variable দেয়।</span></code></pre>
<ul class="list">
<li><p>ত্রুটির (Error) ধরনের মধ্যে রয়েছে: Syntax, Reference, এবং Type।</p>
<ul class="list">
<li><p>Uncaught ReferenceError: x is not defined at …</p>
<ul class="list">
<li>এই Error নির্দেশ করে যে x কখনই প্রোগ্রামের স্কোপে ছিল না। এটাই মানে x ডিক্লেয়ার বা ডিফাইন হয়নি এবং এক্সেস করার চেষ্টা করা হয়েছে।</li>
</ul>
</li>
<li><p>Uncaught ReferenceError: cannot access 'a' before initialization</p>
<ul class="list">
<li>এই Error দেখায় যে 'a' অ্যাক্সেস করা যাচ্ছে না কারণ এটি 'let' দিয়ে ডিক্লেয়ার করা হয়েছে এবং এটি Temporal Dead Zone-এ রয়েছে। ফলে error ঘটে।</li>
</ul>
</li>
<li><p>Uncaught SyntaxError: Identifier 'a' has already been declared</p>
<ul class="list">
<li>এই Error নির্দেশ করে আমরা একটি ভ্যারিয়েবল পুনরায় ডিক্লেয়ার করছি যা আগে থেকেই 'let' দিয়ে ডিক্লেয়ার করা হয়েছিল। কোনো execution হবে না।</li>
</ul>
</li>
<li><p>Uncaught SyntaxError: Missing initializer in const declaration</p>
<ul class="list">
<li>এই Error নির্দেশ করে আমরা const ডিক্লেয়ার করেছি কিন্তু কোনো মান অ্যাসাইন নেই।</li>
</ul>
</li>
<li><p>Uncaught TypeError: Assignment to constant variable</p>
<ul class="list">
<li>এই Error নির্দেশ করে আমরা একটি const ভ্যারিয়েবলে reassign করার চেষ্টা করছি।</li>
</ul>
</li>
</ul>
</li>
</ul>

<h3 id="some-good-practices"><a class="header-link" href="#some-good-practices"></a>কিছু ভালো অভ্যাস:</h3>
<ul class="list">
<li>যতটা সম্ভব const ব্যবহার করার চেষ্টা করুন।</li>
<li>যদি না হয়, let ব্যবহার করুন, var এড়িয়ে চলুন।</li>
<li>সমস্ত ভেরিয়েবল let দিয়ে শীর্ষে ঘোষণা এবং initialize করুন যাতে error এড়ানো যায় এবং temporal dead zone উইন্ডো শূন্যে নামিয়ে আনা যায়।</li>
</ul>
<hr>

<p>ইউটিউবে লাইভ দেখুন নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=BNC6slYCj50&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/BNC6slYCj50/0.jpg" width="750"
alt="let & const in JS, Temporal Dead Zone Youtube Link"/></a></p>
<br>

<hr>

<br>

<h1 id="episode-9--block-scope--shadowing-in-js"><a class="header-link" href="#episode-9--block-scope--shadowing-in-js"></a>Episode 9 : Block Scope &amp; Shadowing in JS</h1>
<p><strong>Block</strong> কি?</p>
<ul class="list">
<li>Block বা <em>compound statement</em> ব্যবহার হয় JS স্টেটমেন্টগুলোকে একসাথে একটি গ্রুপে আনতে। আমরা এগুলো {...} এর মধ্যে রাখি।</li>
</ul>
<pre class="hljs"><code>{
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;
  <span class="hljs-keyword">const</span> c = <span class="hljs-number">30</span>;
  <span class="hljs-comment">// এখানে let এবং const block scope এ hoist হয়,</span>
  <span class="hljs-comment">// আর var hoist হয় global scope এ।</span>
}</code></pre><ul class="list">
<li>Block Scope এবং এর accessibility উদাহরণ</li>
</ul>
<pre class="hljs"><code>{
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;
  <span class="hljs-keyword">const</span> c = <span class="hljs-number">30</span>;
}
<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// Uncaught ReferenceError: b is not defined</span></code></pre><pre class="hljs"><code><span class="hljs-comment">* কারণ?
    * BLOCK SCOPE এ; b এবং c hoist হয় undefined দিয়ে, আলাদা একটি মেমোরি স্পেসে যাকে **block** বলে।
    * আর a global scope এ store হয়।

    * তাই আমরা বলি, *let* এবং *const* BLOCK SCOPED। এগুলো আলাদা মেম স্পেসে store হয় যা শুধুমাত্র ওই block এর জন্য reserved। এবং block এর বাইরে এগুলো access করা যায় না। কিন্তু var a global scope এ থাকে, তাই যেকোনো জায়গা থেকে access করা যায়।</span></code></pre><p><strong>Shadowing</strong> কি?</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>;
{
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// global var এর সাথে একই নাম</span>
  <span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;
  <span class="hljs-keyword">const</span> c = <span class="hljs-number">30</span>;
  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 10</span>
  <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 20</span>
  <span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 30</span>
}
<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 10, যদিও আমরা 100 আশা করেছিলাম। block এর ভেতরের "a" global "a" এর মানকেও modify করেছে। console এ শুধু b এবং c block এ store থাকে। a global এ ছিল (a = 100), কিন্তু যখন a = 10 লাইন চলে, তখন নতুন a তৈরি হয় না, বরং global a এর মান replace হয়ে যায়।</span></code></pre><ul class="list">
<li><p>তাহলে, যদি block এর বাইরে একই নামের ভেরিয়েবল থাকে, তবে block এর ভেতরের ভেরিয়েবল বাইরের ভেরিয়েবলকে <em>shadow</em> করে। <strong>এটা শুধু var এর জন্য ঘটে</strong></p>
</li>
<li><p>এবার let এবং const এর ক্ষেত্রে কি হয় সেটা দেখি।</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">let</span> b = <span class="hljs-number">100</span>;
{
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;
  <span class="hljs-keyword">const</span> c = <span class="hljs-number">30</span>;
  <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 20</span>
}
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 100, দুটি b আলাদা স্পেসে থাকে (একটি Block এ 20, আরেকটি Script/global এ 100)। const এর ক্ষেত্রেও একই।</span></code></pre><p class="img-container"><img src="./images/scope.jpg" alt="Block Scope Explaination" title="Lexical Scope"></p>
<ul class="list">
<li>একই logic function এর ক্ষেত্রেও সত্যি।</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">const</span> c = <span class="hljs-number">100</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> c = <span class="hljs-number">10</span>;
  <span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 10</span>
}
x();
<span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 100</span></code></pre><p><strong>Illegal Shadowing</strong> কি?</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;
{
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>;
}
<span class="hljs-comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></code></pre><ul class="list">
<li>আমরা let কে var দিয়ে shadow করতে পারি না। কিন্তু let কে let দিয়ে shadow করা বৈধ। এছাড়াও var কে let দিয়ে shadow করা যায়।</li>
<li>Function এ যেভাবে scope rule কাজ করে, arrow function এও একইভাবে কাজ করে।</li>
<li>যেহেতু var function scoped, তাই নিচের কোডে কোনো সমস্যা নেই।</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>;
}</code></pre><hr>

<p>ইউটিউবে লাইভ দেখুন নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=lW_erSjyMeM&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/lW_erSjyMeM/0.jpg" width="750"
alt="Block Scope & Shadowing in JS Youtube Link"/></a></p>
<br>

<hr>

<br>

<h1 id="episode-10--closures-in-js"><a class="header-link" href="#episode-10--closures-in-js"></a>Episode 10 : Closures in JS</h1>
<ul class="list">
<li><p>Function এবং তার lexical scope একসাথে bundle থাকলে তাকে <strong>closure</strong> বলে।</p>
</li>
<li><p>JavaScript এ lexical scope environment আছে। কোনো function যদি কোনো ভেরিয়েবল access করতে চায়, তবে প্রথমে local memory খুঁজবে। যদি না পায় তবে তার lexical parent এর মেমোরিতে যাবে। নিচের কোডে function <strong>y</strong> তার lexical scope (function x) সহ closure।</p>
<pre class="prettyprint">function x() {
  var a = 7;
  function y() {
    console.log(a);
  }
  return y;
}
var z = x();
console.log(z); // z এর মান হলো পুরো function y এর কোড।
</pre>
<ul class="list">
<li><p>উপরের কোডে, যখন y return হয়, শুধু function নয় বরং পুরো closure (fun y + তার lexical scope) return হয় এবং z তে store হয়। তাই z যখন অন্য জায়গায় ব্যবহার হয় তখনও এটি x() এর ভেতরের a কে মনে রাখে।</p>
</li>
<li><p>আরেকটি উদাহরণ:</p>
<pre class="prettyprint">function z() {
  var b = 900;
  function x() {
    var a = 7;
    function y() {
      console.log(a, b);
    }
    y();
  }
  x();
}
z(); // 7 900
</pre>
</li>
</ul>
</li>
<li><p>সহজভাবে বলতে গেলে:</p>
<ul class="list">
<li><strong>*Closure হলো এমন একটি function</strong> যা তার outer function এর scope এ access পায়, এমনকি outer function return করার পরও। মানে, Closure outer function এর ভেরিয়েবল এবং argument reference মনে রাখতে পারে এবং access করতে পারে।*</li>
</ul>
</li>
</ul>
<br>

<ul class="list">
<li><p class="img-container"><img src="./images/closure.jpg" alt="Closure Explaination" title="Lexical Scope"></p>
</li>
<li><p>Closure এর সুবিধা:</p>
<pre class="prettyprint">চলুন প্রতিটি সুবিধার উদাহরণ দেখি:
</pre>
<ol class="list">
<li><p><strong>Module Design Pattern</strong>:</p>
<ul class="list">
<li><p>Module design pattern আমাদের সম্পর্কিত functionality একসাথে একটি module বা ফাইলে রাখতে সাহায্য করে। এটি কোড organize করে, global namespace দূষণ রোধ করে এবং reusability বাড়ায়।</p>
</li>
<li><p>উদাহরণ: ধরুন আমরা একটি web app বানাচ্ছি এবং user authentication এর জন্য একটি module চাই। আমরা একটি <code>auth.js</code> বানাতে পারি যেখানে <code>login</code>, <code>logout</code>, <code>getUserInfo</code> থাকবে।</p>
<pre class="prettyprint">// auth.js
const authModule = (function () {
  let loggedInUser = null;

  function login(username, password) {
    // Authenticate user logic...
    loggedInUser = username;
  }

  function logout() {
    loggedInUser = null;
  }

  function getUserInfo() {
    return loggedInUser;
  }

  return {
    login,
    logout,
    getUserInfo,
  };
})();

// ব্যবহার
authModule.login(&quot;john_doe&quot;, &quot;secret&quot;);
console.log(authModule.getUserInfo()); // &#39;john_doe&#39;
</pre>
</li>
</ul>
</li>
<li><p><strong>Currying</strong>:</p>
<ul class="list">
<li><p>Currying হলো এমন একটি কৌশল যেখানে একটি multi-argument function কে একাধিক single-argument function এ ভাগ করা হয়। এটি partial function application এবং কোডের flexibility বাড়ায়।</p>
</li>
<li><p>উদাহরণ: tax সহ মোট price বের করার জন্য curried function:</p>
<pre class="prettyprint">const calculateTotalPrice = (taxRate) =&gt; (price) =&gt;
  price + price * (taxRate / 100);

const calculateSalesTax = calculateTotalPrice(8); // 8% sales tax
const totalPrice = calculateSalesTax(100); // Tax সহ price
console.log(totalPrice); // 108
</pre>
</li>
</ul>
</li>
<li><p><strong>Memoization</strong>:</p>
<ul class="list">
<li><p>Memoization ব্যয়বহুল function call optimize করে cache এর মাধ্যমে। এটি recursive বা repeated computation এর জন্য দরকারি।</p>
</li>
<li><p>উদাহরণ: memoized Fibonacci function:</p>
<pre class="prettyprint">function fibonacci(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n &lt;= 1) return n;

  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
  return memo[n];
}

console.log(fibonacci(10)); // 55
</pre>
</li>
</ul>
</li>
<li><p><strong>Data Hiding এবং Encapsulation</strong>:</p>
<ul class="list">
<li><p>Encapsulation object এর internal details hide করে এবং শুধুমাত্র প্রয়োজনীয় method/properties expose করে। এতে কোড maintainability এবং security বাড়ে।</p>
</li>
<li><p>উদাহরণ: একটি <code>Person</code> class যেখানে private property থাকবে:</p>
<pre class="prettyprint">class Person {
  #name; // Private field

  constructor(name) {
    this.#name = name;
  }

  getName() {
    return this.#name;
  }
}

const person = new Person(&quot;Alice&quot;);
console.log(person.getName()); // &#39;Alice&#39;
// console.log(person.#name); // Error: Private field &#39;#name&#39; must be declared in an enclosing class
</pre>
</li>
</ul>
</li>
<li><p><strong>setTimeouts</strong>:</p>
<ul class="list">
<li><p><code>setTimeout</code> একটি function কে নির্দিষ্ট delay পরে run করায়। এটি asynchronous কাজ, animation এবং event handling এর জন্য ব্যবহৃত হয়।</p>
</li>
<li><p>উদাহরণ: delayed message display:</p>
<pre class="prettyprint">function showMessage(message, delay) {
  setTimeout(() =&gt; {
    console.log(message);
  }, delay);
}

showMessage(&quot;Hello, world!&quot;, 2000); // 2 সেকেন্ড পরে দেখাবে
</pre>
</li>
</ul>
</li>
</ol>
<p>এই উদাহরণগুলো Closure এর power এবং versatility দেখায়! 🚀</p>
</li>
<li><p>Closure এর অসুবিধা:</p>
<ul class="list">
<li>অতিরিক্ত মেমোরি খরচ</li>
<li>Memory Leak</li>
<li>Browser freeze হতে পারে</li>
</ul>
</li>
</ul>
<hr>

<p>ইউটিউবে লাইভ দেখুন নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=qikxEIxsXco&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/qikxEIxsXco/0.jpg" width="750"
alt="Closure in JS Youtube Link"/></a></p>
<br>

<hr>

<br>


<h1 id="episode-11--settimeout--closures-interview-question">
  <a class="header-link" href="#episode-11--settimeout--closures-interview-question"></a>
  Episode 11 : setTimeout + Closures Interview Question
</h1>
<blockquote>
<p><strong>সময়, জোয়ার আর Javascript কারো জন্য অপেক্ষা করে না।</strong></p>
</blockquote>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(i);
  }, <span class="hljs-number">3000</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Namaste Javascript&quot;</span>);
}
x();
<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// Namaste Javascript</span>
<span class="hljs-comment">// 1 // after waiting 3 seconds</span></code></pre>
<ul class="list">
<li><p>আমরা আশা করি JS ৩ সেকেন্ড অপেক্ষা করবে, তারপর ১ প্রিন্ট করবে এবং পরে স্ট্রিং প্রিন্ট করবে। কিন্তু JS সাথে সাথে স্ট্রিং প্রিন্ট করে, তারপর ৩ সেকেন্ড অপেক্ষা করে এবং পরে ১ প্রিন্ট করে।</p></li>
<li><p>setTimeout এর ভেতরের ফাংশন একটা closure তৈরি করে (মানে i এর reference মনে রাখে)। তাই ফাংশন যেখানেই যাক, সেই reference সাথে নিয়ে যায়।</p></li>
<li><p>setTimeout এই callback ফাংশনটা নেয় এবং 3000ms এর টাইমার লাগিয়ে রাখে। এটা অপেক্ষা না করে পরের লাইনে গিয়ে স্ট্রিং প্রিন্ট করে ফেলে।</p></li>
<li><p>3000ms শেষ হওয়ার পর, JS ফাংশনটাকে call stack এ পাঠায় এবং এক্সিকিউট করে।</p></li>
<li><p>প্রশ্ন: ১ সেকেন্ড পরে ১, ২ সেকেন্ড পরে ২ … এভাবে ৫ পর্যন্ত প্রিন্ট করো → খুব সাধারণ ইন্টারভিউ প্রশ্ন</p></li>
<p>আমরা ভাবি এরকম সোজা সমাধান হবে:</p>
<pre class="prettyprint">function x() {
  for (var i = 1; i &lt;= 5; i++) {
    setTimeout(function () {
      console.log(i);
    }, i * 1000);
  }
  console.log(&quot;Namaste Javascript&quot;);
}
x();
// Output:
// Namaste Javascript
// 6
// 6
// 6
// 6
// 6
</pre>
<ul class="list">
<li><p>কারণ?</p>
<ul class="list">
<li><p>এটা হচ্ছে closures এর কারণে। setTimeout যখন ফাংশন স্টোর করে, তখন সেটা i এর <strong>value না, reference</strong> মনে রাখে। ৫টা ফাংশনই একই reference এর সাথে যুক্ত থাকে। লুপ শেষ হলে i = ৬ হয়ে যায়। তখন সব ফাংশন i = ৬ পায়, তাই পাঁচবারই ৬ প্রিন্ট হয়।</p></li>
<li><p>এটা এড়াতে আমরা <strong>let</strong> ব্যবহার করতে পারি var এর বদলে। let block scope এ নতুন i বানায় প্রতিবার। ফলে প্রত্যেকবার নতুন reference হয়।</p></li>
</ul>
</li>
<li><p>কিন্তু যদি interviewer বলে var দিয়েই করতে?</p>
<pre class="prettyprint">function x() {
  for (var i = 1; i &lt;= 5; i++) {
    function close(i) {
      setTimeout(function () {
        console.log(i);
      }, i * 1000);
      // put the setT function inside new function close()
    }
    close(i); // everytime you call close(i) it creates new copy of i. Only this time, it is with var itself!
  }
  console.log(&quot;Namaste Javascript&quot;);
}
x();
</pre>
</li>
</ul>
</li>
</ul>

<hr>
<p>লাইভ দেখো YouTube এ নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=eBTBG4nda2A&ab_channel=AkshaySaini" target="_blank">
<img src="https://img.youtube.com/vi/eBTBG4nda2A/0.jpg" width="750" alt="setTimeout + Closures Interview Question in JS Youtube Link"/>
</a></p>
<br><hr><br>


<h1 id="episode-12--famous-interview-questions-ft-closures">
  <a class="header-link" href="#episode-12--famous-interview-questions-ft-closures"></a>
  Episode 12 : Famous Interview Questions ft. Closures
</h1>

<h3 id="q1-what-is-closure-in-javascript">Q1: What is Closure in Javascript?</h3>
<p><strong>উত্তর</strong>: কোনো ফাংশন এবং তার outer environment এর reference মিলে closure তৈরি হয়। অর্থাৎ function + lexical scope bundle হয়ে closure।</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(a);
  } <span class="hljs-comment">// inner forms a closure with outer</span>
  <span class="hljs-keyword">return</span> inner;
}
outer()(); <span class="hljs-comment">// 10 // over here first `()` will return inner function and then using second `()` to call inner function</span></code></pre>

<h3 id="q2-will-the-below-code-still-forms-a-closure">Q2: Will the below code still forms a closure?</h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(a);
  }
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">return</span> inner;
}
outer()(); <span class="hljs-comment">// 10</span></code></pre>
<p><strong>উত্তর</strong>: হ্যাঁ, কারণ inner function সবসময় outer environment এর সাথে closure তৈরি করে। sequence কোনো ব্যাপার না।</p>

<h3 id="q3-changing-var-to-let-will-it-make-any-difference">Q3: Changing var to let, will it make any difference?</h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(a);
  }
  <span class="hljs-keyword">return</span> inner;
}
outer()(); <span class="hljs-comment">// 10</span></code></pre>
<p><strong>উত্তর</strong>: কোনো পার্থক্য হবে না, একইভাবে কাজ করবে।</p>

<h3 id="q4-will-inner-function-have-the-access-to-outer-function-argument">Q4: Will inner function have the access to outer function argument?</h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params">str</span>) </span>{
  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(a, str);
  }
  <span class="hljs-keyword">return</span> inner;
}
outer(<span class="hljs-string">&quot;Hello There&quot;</span>)(); <span class="hljs-comment">// 10 &quot;Hello There&quot;</span></code></pre>
<p><strong>উত্তর</strong>: হ্যাঁ, inner function closure তৈরি করে outer এর variable (a) এবং argument (str) দুইটারই access পায়।</p>

<h3 id="q5-in-below-code-will-inner-form-closure-with-outest">Q5: In below code, will inner form closure with <strong>outest</strong>?</h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outest</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> c = <span class="hljs-number">20</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(a, c, str);
    }
    <span class="hljs-keyword">return</span> inner;
  }
  <span class="hljs-keyword">return</span> outer;
}
outest()(<span class="hljs-string">&quot;Hello There&quot;</span>)(); <span class="hljs-comment">// 10 20 &quot;Hello There&quot;</span></code></pre>
<p><strong>উত্তর</strong>: হ্যাঁ, inner তার সব outer environment এর access রাখে।</p>

<h3 id="q6-output-of-below-code-and-explaination">Q6: Output of below code and explanation?</h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outest</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> c = <span class="hljs-number">20</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(a, c, str);
    }
    <span class="hljs-keyword">return</span> inner;
  }
  <span class="hljs-keyword">return</span> outer;
}
<span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span>;
outest()(<span class="hljs-string">&quot;Hello There&quot;</span>)(); <span class="hljs-comment">// 10 20 &quot;Hello There&quot;</span></code></pre>
<p><strong>উত্তর</strong>: আউটপুট একই থাকবে। inner function নিজের স্কোপ থেকে a নেবে, outer এ যেটা আছে সেটাই প্রাধান্য পাবে। নাম conflict হলেও সমস্যা নেই। JS scope chain ধরে ভ্যারিয়েবল resolve করে।</p>

<h3 id="q7-advantage-of-closure">Q7: Advantage of Closure?</h3>
<ul class="list">
<li>Module Design Pattern</li>
<li>Currying</li>
<li>Memoization</li>
<li>ডাটা লুকানো (Data Hiding) এবং Encapsulation</li>
<li>setTimeouts ইত্যাদি</li>
</ul>

<h3 id="q8-discuss-more-on-data-hiding-and-encapsulation">Q8: Discuss more on Data hiding and encapsulation?</h3>
<p>Closure ব্যবহার করলে ডাটা বাইরের থেকে access করা যায় না, কেবল ফাংশনের ভেতরে থাকে।</p>
<pre class="hljs"><code><span class="hljs-comment">// without closures</span>
<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span>{
  count++;
}
<span class="hljs-comment">// in the above code, anyone can access count and change it.</span>

------------------------------------------------------------------

<span class="hljs-comment">// (with closures) -&gt; put everything into a function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span>{
    count++;
  }
}
<span class="hljs-built_in">console</span>.log(count); <span class="hljs-comment">// this will give referenceError as count can&#x27;t be accessed. So now we are able to achieve hiding of data</span>

------------------------------------------------------------------

<span class="hljs-comment">//(increment with function using closure) true function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span>{
    count++;
    <span class="hljs-built_in">console</span>.log(count);
  }
}
<span class="hljs-keyword">var</span> counter1 = counter(); <span class="hljs-comment">//counter function has closure with count var.</span>
counter1(); <span class="hljs-comment">// increments counter</span>

<span class="hljs-keyword">var</span> counter2 = counter();
counter2(); <span class="hljs-comment">// here counter2 is whole new copy of counter function and it wont impack the output of counter1</span>

*************************

<span class="hljs-comment">// Above code is not good and scalable for say, when you plan to implement decrement counter at a later stage.</span>
<span class="hljs-comment">// To address this issue, we use *constructors*</span>

<span class="hljs-comment">// Adding decrement counter and refactoring code:</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-comment">//constructor function. Good coding would be to capitalize first letter of constructor function.</span>
  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">this</span>.incrementCounter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">//anonymous function</span>
    count++;
    <span class="hljs-built_in">console</span>.log(count);
  }
   <span class="hljs-built_in">this</span>.decrementCounter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    count--;
    <span class="hljs-built_in">console</span>.log(count);
  }
}

<span class="hljs-keyword">var</span> counter1 = <span class="hljs-keyword">new</span> Counter();  <span class="hljs-comment">// new keyword for constructor fun</span>
counter1.incrementCounter();
counter1.incrementCounter();
counter1.decrementCounter();
<span class="hljs-comment">// returns 1 2 1</span></code></pre>

<h3 id="q9-disadvantage-of-closure">Q9: Disadvantage of closure?</h3>
<p><strong>উত্তর</strong>: closure ব্যবহার করলে অনেক সময় variable মেমোরি থেকে clear হয় না, garbage collector ও এগুলো মুছতে পারে না। ফলে memory leak হতে পারে।</p>
<p><strong>Garbage Collector</strong>: JS engine বা browser এর প্রোগ্রাম যেটা অপ্রয়োজনীয় মেমোরি ফ্রি করে। C++ বা JAVA তে এটা developer কে ম্যানুয়ালি করতে হয়, কিন্তু JS এ অটো হয়।</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(x);
  };
}

<span class="hljs-keyword">var</span> y = a(); <span class="hljs-comment">// y is a copy of b()</span>
y();

<span class="hljs-comment">// Once a() is called, its element x should be garbage collected ideally. But fun b has closure over var x. So mem of x cannot be freed. Like this if more closures formed, it becomes an issue. To tacke this, JS engines like v8 and Chrome have smart garbage collection mechanisms. Say we have var x = 0, z = 10 in above code. When console log happens, x is printed as 0 but z is removed automatically.</span></code></pre>

<hr>
<p>লাইভ দেখো YouTube এ নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=t1nFAMws5FI&ab_channel=AkshaySaini" target="_blank">
<img src="https://img.youtube.com/vi/t1nFAMws5FI/0.jpg" width="750" alt="Closures Interview Question in JS Youtube Link"/>
</a></p>
<br><hr><br>


<h1 id="episode-13--first-class-functions-ft-anonymous-functions">
  <a class="header-link" href="#episode-13--first-class-functions-ft-anonymous-functions"></a>
  Episode 13 : First Class Functions ft. Anonymous Functions
</h1>
<blockquote>
<p>Functions হলো Javascript এর হৃদয় ♥।</p>
</blockquote>

<h3 id="q-what-is-function-statement">Q: What is Function statement?</h3>
<p>নিচের পদ্ধতিতে ফাংশন বানানোকে function statement বলে।</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello&quot;</span>);
}
a(); <span class="hljs-comment">// Hello</span></code></pre>

<h3 id="q-what-is-function-expression">Q: What is Function Expression?</h3>
<p>কোনো ফাংশনকে একটা ভ্যারিয়েবলে অ্যাসাইন করলে সেটা function expression।</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello&quot;</span>);
};
b();</code></pre>

<h3 id="q-difference-between-function-statement-and-expression">Q: Difference between function statement and expression</h3>
<p>প্রধান পার্থক্য <strong>Hoisting</strong> এ।</p>
<pre class="hljs"><code>a(); <span class="hljs-comment">// &quot;Hello A&quot;</span>
b(); <span class="hljs-comment">// TypeError</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello A&quot;</span>);
}
<span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello B&quot;</span>);
};
<span class="hljs-comment">// Why? During mem creation phase a is created in memory and function assigned to a. But b is created like a variable (b:undefined) and until code reaches the function()  part, it is still undefined. So it cannot be called.</span></code></pre>

<h3 id="q-what-is-function-declaration">Q: What is Function Declaration?</h3>
<p><strong>function statement</strong> এর আরেক নাম।</p>

<h3 id="q-what-is-anonymous-function">Q: What is Anonymous Function?</h3>
<p>যে ফাংশনের কোনো নাম নেই।</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

}<span class="hljs-comment">// this is going to throw Syntax Error - Function Statement requires function name.</span></code></pre>
<ul class="list">
<li>এগুলোর নিজস্ব পরিচয় নেই, তাই standalone anonymous ফাংশন এরর দেয়।</li>
<li>সাধারণত function expression হিসেবে anonymous function ব্যবহার হয়।</li>
</ul>

<h3 id="q-what-is-named-function-expression">Q: What is Named Function Expression?</h3>
<p>Function expression এ যদি ফাংশনের নাম দেওয়া হয়।</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xyz</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b called&quot;</span>);
};
b(); <span class="hljs-comment">// &quot;b called&quot;</span>
xyz(); <span class="hljs-comment">// Throws ReferenceError:xyz is not defined.</span>
<span class="hljs-comment">// xyz function is not created in global scope. So it can&#x27;t be called.</span></code></pre>

<h3 id="q-parameters-vs-arguments">Q: Parameters vs Arguments?</h3>
<p>Parameter হলো function এর ভেতরে label, আর Argument হলো function কল করার সময় value।</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param1, param2</span>) </span>{
  <span class="hljs-comment">// labels/identifiers are parameters</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b called&quot;</span>);
};
b(arg1, arg2); <span class="hljs-comment">// arguments - values passed inside function call</span></code></pre>

<h3 id="q-what-is-first-class-function-aka-first-class-citizens">Q: What is First Class Function aka First Class Citizens?</h3>
<p>ফাংশনকে অন্য ফাংশনের argument হিসেবে পাঠানো বা return করা যায়। এই ক্ষমতাকেই বলে First Class Function।</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param1</span>) </span>{
  <span class="hljs-built_in">console</span>.log(param1); <span class="hljs-comment">// prints &quot; f() {} &quot;</span>
};
b(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{});

<span class="hljs-comment">// Other way of doing the same thing:</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param1</span>) </span>{
  <span class="hljs-built_in">console</span>.log(param1);
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xyz</span>(<span class="hljs-params"></span>) </span>{}
b(xyz); <span class="hljs-comment">// same thing as prev code</span>

<span class="hljs-comment">// we can return a function from a function:</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param1</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
};
<span class="hljs-built_in">console</span>.log(b()); <span class="hljs-comment">//we log the entire fun within b.</span></code></pre>

<hr>
<p>লাইভ দেখো YouTube এ নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=SHINoHxvTso&ab_channel=AkshaySaini" target="_blank">
<img src="https://img.youtube.com/vi/SHINoHxvTso/0.jpg" width="750" alt="First Class Functions ft. Anonymous Functions in JS Youtube Link"/>
</a></p>
<br><hr><br>


<h1 id="episode-14--callback-functions-in-js-ft-event-listeners">
  <a class="header-link" href="#episode-14--callback-functions-in-js-ft-event-listeners"></a>
  Episode 14 : Callback Functions in JS ft. Event Listeners
</h1>

<h3 id="callback-functions">Callback Functions</h3>
<ul class="list">
<li>Functions হলো first class citizens। মানে Function A কে Function B এর argument হিসেবে পাঠানো যায়। এখানে A হলো callback function। এই callback ফাংশনের মাধ্যমেই আমরা synchronous ভাষায় asynchronous কাজ করতে পারি।</li>
</ul>

<pre class="hljs"><code><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Timer&quot;</span>);
}, <span class="hljs-number">1000</span>); <span class="hljs-comment">// first argument is callback function and second is timer.</span></code></pre>

<ul class="list">
<li>JS আসলে synchronous এবং single-threaded ভাষা। কিন্তু callback এর কারণে JS এ async কাজ সম্ভব।</li>
</ul>



<pre class="hljs"><code><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;timer&quot;</span>);
}, <span class="hljs-number">5000</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params">y</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;x&quot;</span>);
  y();
}
x(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;y&quot;</span>);
});
<span class="hljs-comment">// x y timer</span></code></pre>
<ul class="list">
<li>Call stack-এ প্রথমে x আর y থাকে। কোড এক্সিকিউশনের পর তারা চলে যায় আর stack ফাঁকা হয়। তারপর ৫ সেকেন্ড পরে (শুরু থেকে) anonymous হঠাৎ stack-এ উঠে আসে অর্থাৎ setTimeout।</li>
<li>সব ৩টা ফাংশন Call stack দিয়েই রান হয়। যদি কোনো অপারেশন stack ব্লক করে, সেটাকে বলে main thread ব্লক করা।</li>
<li>ধরা যাক x() রান করতে ৩০ সেকেন্ড লাগে, তাহলে JS-কে সেটা শেষ না হওয়া পর্যন্ত অপেক্ষা করতে হবে কারণ JS-এর মাত্র ১টা call stack / main thread আছে। কখনও main thread ব্লক করবে না।</li>
<li>যে ফাংশনগুলো সময় নেয় (যেমন setTimeout), সেগুলোর জন্য সবসময় <strong>async</strong> ব্যবহার করো।</li>
</ul>

<pre class="hljs"><code><span class="hljs-comment">// Another Example of callback</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printStr</span>(<span class="hljs-params">str, cb</span>) </span>{
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(str);
    cb();
  }, <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>) + <span class="hljs-number">1</span>);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printAll</span>(<span class="hljs-params"></span>) </span>{
  printStr(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    printStr(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-function">() =&gt;</span> {
      printStr(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-function">() =&gt;</span> {});
    });
  });
}
printAll(); <span class="hljs-comment">// A B C // in order</span></code></pre>

<h3 id="event-listener"><a class="header-link" href="#event-listener"></a>Event Listener</h3>
<ul class="list">
<li>আমরা html-এ একটা বাটন বানাবো আর তার সাথে event অ্যাটাচ করবো।</li>
</ul>

<pre class="hljs"><code><span class="hljs-comment">// index.html</span>
&lt;button id=<span class="hljs-string">&quot;clickMe&quot;</span>&gt;Click Me!&lt;/button&gt;;

<span class="hljs-comment">// in index.js</span>
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;clickMe&quot;</span>).addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xyz</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// যখন click ইভেন্ট হয়, তখন এই callback function (xyz) call stack-এ ঢোকে</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Button clicked&quot;</span>);
});</code></pre>

<ul class="list">
<li>চলো একটা increment counter বাটন বানাই।<ul class="list">
<li>Global variable ব্যবহার করে (ভালো না, কারণ যে কেউ এটা পরিবর্তন করতে পারবে)<pre class="prettyprint">let count = 0;
document
  .getElementById(&quot;clickMe&quot;)
  .addEventListener(&quot;click&quot;, function xyz() {
    console.log(&quot;Button clicked&quot;, ++count);
  });
</pre>
</li>
<li>Data abstraction-এর জন্য closure ব্যবহার করো<pre class="prettyprint">function attachEventList() {
  //closure এর জন্য নতুন ফাংশন তৈরি করছি
  let count = 0;
  document
    .getElementById(&quot;clickMe&quot;)
    .addEventListener(&quot;click&quot;, function xyz() {
      console.log(&quot;Button clicked&quot;, ++count); //এখন callback function outer scope(count)-এর সাথে closure তৈরি করছে
    });
}
attachEventList();
</pre>
<img src="./images/event.jpg" alt="Event Listerner Demo"></li>
</ul>
</li>
</ul>

<h3 id="garbage-collection-and-removeeventlisteners"><a class="header-link" href="#garbage-collection-and-removeeventlisteners"></a>Garbage Collection and removeEventListeners</h3>
<ul class="list">
<li>Event listener-গুলো heavy কারণ এরা closure তৈরি করে। তাই call stack ফাঁকা থাকলেও EventListener memory free করবে না কারণ সে জানে না কবে আবার count লাগতে পারে। এজন্য event listener গুলো যখন দরকার নেই তখন remove করতে হয় (garbage collected)। এক পেজে onClick, onHover, onScroll একসাথে থাকলে সেটা অনেক slow করে দেয়।</li>
</ul>
<hr>

<p>নিচে YouTube এ লাইভ দেখো:</p>
<p><a href="https://www.youtube.com/watch?v=btj35dh3_U8&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/btj35dh3_U8/0.jpg" width="750"
alt="Callback Functions in JS ft. Event Listeners in JS Youtube Link"/></a></p>
<br>
<hr>
<br>

<h1 id="episode-15--asynchronous-javascript--event-loop-from-scratch"><a class="header-link" href="#episode-15--asynchronous-javascript--event-loop-from-scratch"></a>Episode 15 : Asynchronous JavaScript &amp; EVENT LOOP from scratch</h1>
<blockquote>
<p>Note: Call stack যেকোনো execution context-কে execute করবে যা এতে ঢোকে। সময়, জোয়ার-ভাটা বা JS কারো জন্য অপেক্ষা করে না। সংক্ষেপে; Call stack-এর কোনো timer নেই।</p>
</blockquote>

<ul class="list">
<li>Browser-এর ভেতরে JS Engine থাকে, যার মধ্যে Call Stack থাকে, যেখানে Global execution context, local execution context ইত্যাদি থাকে।<ul class="list">
<li>কিন্তু browser-এর আরও অনেক superpower আছে - Local storage space, Timer, URL প্রবেশ করানোর জায়গা, Bluetooth access, Geolocation access ইত্যাদি।</li>
<li>এখন JS-এর দরকার callstack আর এই superpower-গুলোর সাথে connect করার উপায়। এটা করা হয় Web APIs দিয়ে।
<img src="./images/eventloop1.jpg" alt="Event Loop 1 Demo"></li>
</ul>
</li>
</ul>

<h3 id="webapis"><a class="header-link" href="#webapis"></a>WebAPIs</h3>
<p>নিচের কোনোটাই JavaScript-এর অংশ নয়! এগুলো ব্রাউজারের extra superpower। Browser JS callstack-কে এগুলোর access দেয়।
<img src="./images/eventloop2.jpg" alt="Event Loop 2 Demo"></p>

<ul class="list">
<li><p>setTimeout(), DOM APIs, fetch(), localstorage, console (হ্যাঁ, console.log-ও JS না!!), location আর আরও অনেক কিছু।</p>
<ul class="list">
<li>setTimeout() : Timer function</li>
<li>DOM APIs : যেমন Document.xxxx ; HTML DOM tree access করার জন্য (Document Object Manipulation)</li>
<li>fetch() : বাইরের server-এর সাথে connect করার জন্য (যেমন Netflix servers)</li>
</ul>
</li>

<li><p>আমরা এগুলো call stack-এর ভেতরে পাই global object অর্থাৎ window এর মাধ্যমে</p>
<ul class="list">
<li>window ব্যবহার করে যেমন: window.setTimeout(), window.localstorage, window.console.log() ইত্যাদি।</li>
<li>যেহেতু window global object, আর এগুলো সব global object-এ present থাকে, তাই আমরা আলাদা করে window লিখি না — implicit ধরে নেয়া হয়।</li>
</ul>
</li>

<li><p>চলো নিচের কোড আর ব্যাখ্যাটা বুঝি:
<img src="./images/eventloop3.jpg" alt="Event Loop 3 Demo"></p>
<ul class="list">
<li><pre class="prettyprint">console.log(&quot;start&quot;);
setTimeout(function cb() {
  console.log(&quot;timer&quot;);
}, 5000);
console.log(&quot;end&quot;);
// start end timer
</pre></li>
<li>প্রথমে একটা GEC তৈরি হয় আর call stack-এ যায়।</li>
<li>console.log(&quot;Start&quot;); // এটা console web api (window এর মাধ্যমে) কে কল করে যেটা console-এর ভেতরে ভ্যালু পরিবর্তন করে।</li>
<li>setTimeout(function cb() { // এটা setTimeout web api-কে কল করে যেটা timer ফিচার access দেয়। cb() callback স্টোর করে টাইমার চালু হয়। console.log(&quot;Callback&quot;);}, 5000);</li>
<li>console.log(&quot;End&quot;); // console api-কে কল করে আর console window-এ লগ করে। এরপর GEC call stack থেকে pop হয়।</li>
<li>এই সবের মধ্যে টাইমার ক্রমাগত চলছে। যখন ০ হয়, তখন callback cb() রান করতে হবে।</li>
<li>এখন cb-কে call stack-এ ঢুকতে হবে। কেবল তখনই এটা execute হবে। এজন্য আমাদের দরকার <strong>event loop</strong> আর <strong>Callback queue</strong>।</li>
</ul>
</li>
</ul>


<h3 id="event-loops-and-callback-queue"><a class="header-link" href="#event-loops-and-callback-queue"></a>Event Loops and Callback Queue</h3>
<p>প্রশ্ন: ৫ সেকেন্ড পরে টাইমার কিভাবে কনসোলে গেল?</p>
<ul class="list">
<li>cb() সরাসরি কল স্ট্যাকে গিয়ে এক্সিকিউট হতে পারে না। টাইমার শেষ হলে সেটা আগে Callback Queue তে যায়।</li>
<li>Event loop সবসময় Callback Queue চেক করতে থাকে, কিছু থাকলে সেটা কল স্ট্যাকে পাঠায়। যেন গেট কিপারের মতো।</li>
<li>একবার cb() Callback Queue তে গেলে, eventloop সেটাকে Call Stack এ পুশ করে রান করায়। Console API ব্যবহার হয় আর লগ প্রিন্ট হয়।</li>
<li><img src="./images/eventloop4.jpg" alt="Event Loop 4 Demo"></li>
</ul>
<p>প্রশ্ন: আরেকটা উদাহরণ Eventloop & Callback Queue বুঝতে।</p>
<p>নিচের ইমেজ আর কোডটা দেখো আর বোঝার চেষ্টা করো:
<img src="./images/eventloop5.jpg" alt="Event Loop 5 Demo">
ব্যাখ্যা?</p>
<ul class="list">
<li><pre class="prettyprint">console.log("Start");
document.getElementById("btn").addEventListener("click", function cb() {
  // cb() webapi environment এ রেজিস্টার হয় আর event(click) attach হয়।
  console.log("Callback");
});
console.log("End"); 
// উপরের কোডে, "Start" আর "End" প্রিন্ট হয়ে GEC স্ট্যাক থেকে pop হলেও EventListener webapi env তে থেকে যায়,
// যতক্ষণ না ব্রাউজার ক্লোজ হয় বা explicitly remove করা হয়।
</pre>
</li>
<li><p>Eventloop-এর কাজ শুধু Callback Queue চেক করা আর কিছু থাকলে কল স্ট্যাকে পাঠানো।</p>
</li>
</ul>
<p>প্রশ্ন: Callback Queue দরকার কেন?</p>
<p><strong>উত্তর</strong>: ধরো ইউজার বাটনে ৬ বার ক্লিক করলো। তাহলে ৬টা cb() Callback Queue তে যাবে। Event loop দেখে Call Stack ফাঁকা আছে কি না, থাকলে Callback Queue থেকে একে একে Call Stack এ পাঠাবে, এক্সিকিউট করবে, তারপর pop করবে।</p>
<br>

<h3 id="behaviour-of-fetch-microtask-queue"><a class="header-link" href="#behaviour-of-fetch-microtask-queue"></a>Behaviour of fetch (<strong>Microtask Queue?</strong>)</h3>
<p>নিচের কোডটা দেখে বোঝার চেষ্টা করি</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Start"</span>); <span class="hljs-comment">// this calls the console web api (through window) which in turn actually modifies values in console.</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cbT</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"CB Timeout"</span>);
}, <span class="hljs-number">5000</span>);
fetch(<span class="hljs-string">"https://api.netflix.com"</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cbF</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"CB Netflix"</span>);
}); <span class="hljs-comment">// take 2 seconds to bring response</span>
<span class="hljs-comment">// millions lines of code</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"End"</span>);

Code Explaination:
* Same steps <span class="hljs-keyword">for</span> everything before fetch() <span class="hljs-keyword">in</span> above code.
* fetch registers cbF into webapi environment along <span class="hljs-keyword">with</span> existing cbT.
* cbT is waiting <span class="hljs-keyword">for</span> 5000ms to end so that it can be put inside callback queue. cbF is waiting <span class="hljs-keyword">for</span> data to be returned <span class="hljs-keyword">from</span> Netflix servers gonna take <span class="hljs-number">2</span> seconds.
* After <span class="hljs-built_in">this</span> millions <span class="hljs-keyword">of</span> lines <span class="hljs-keyword">of</span> code is running, by the time millions line <span class="hljs-keyword">of</span> code will execute, <span class="hljs-number">5</span> seconds has finished and now the timer has expired and response <span class="hljs-keyword">from</span> Netflix server is ready.
* Data back <span class="hljs-keyword">from</span> cbF ready to be executed gets stored into something called a Microtask Queue.
* Also after expiration <span class="hljs-keyword">of</span> timer, cbT is ready to execute <span class="hljs-keyword">in</span> Callback Queue.
* Microtask Queue is exactly same <span class="hljs-keyword">as</span> Callback Queue, but it has higher priority. Functions <span class="hljs-keyword">in</span> Microtask Queue are executed earlier than Callback Queue.
* In <span class="hljs-built_in">console</span>, first Start and End are printed <span class="hljs-keyword">in</span> <span class="hljs-built_in">console</span>. First cbF goes <span class="hljs-keyword">in</span> callstack and <span class="hljs-string">"CB Netflix"</span> is printed. cbF popped <span class="hljs-keyword">from</span> callstack. Next cbT is removed <span class="hljs-keyword">from</span> callback Queue, put <span class="hljs-keyword">in</span> Call Stack, <span class="hljs-string">"CB Timeout"</span> is printed, and cbT removed <span class="hljs-keyword">from</span> callstack.
* See below Image <span class="hljs-keyword">for</span> more understanding</code></pre>

<p><img src="./images/eventloop6.jpg" alt="Event Loop 6 Demo">
Microtask Priority Visualization
<img src="./images/microtask.gif" alt="Event Loop 7 Demo"></p>

<h4 id="what-enters-the-microtask-queue-"><a class="header-link" href="#what-enters-the-microtask-queue-"></a>What enters the Microtask Queue ?</h4>
<ul class="list">
<li>Promise এর callback সবসময় Microtask Queue তে যায়।</li>
<li><strong>Mutation Observer</strong>: DOM tree তে কোন পরিবর্তন হলে callback এক্সিকিউট করে।</li>
<li>Promises আর Mutation Observer → Microtask Queue এ যায়।</li>
<li>বাকিগুলো Callback Queue aka Task Queue তে যায়।</li>
<li>যদি Microtask Queue ক্রমাগত নতুন টাস্ক বানায় তাহলে Callback Queue তে থাকা টাস্ক রান করার সুযোগ পায় না। একে বলে <strong>Starvation</strong>।</li>
</ul>

<h3 id="some-important-questions"><a class="header-link" href="#some-important-questions"></a>Some Important Questions</h3>
<ol class="list">
<li><p><strong>Event loop কবে শুরু হয়?</strong> - Event loop সবসময় রান করে, প্রায় অসীম লুপ। এটা কখনো থামে না।</p></li>
<li><p><strong>সিঙ্ক্রোনাস callback গুলোও কি WebAPI environment এ যায়?</strong> - না। শুধু async callback গুলো যায়। map, filter, reduce এর callback যায় না।</p></li>
<li><p><strong>Web API environment কি শুধু callback রেফারেন্স ধরে রাখে?</strong> - হ্যাঁ, ফাংশন রেফারেন্স রাখা হয় আর সেটা Queue/Microtask Queue তে পাঠানো হয়। EventListener এর callback গুলো explicit remove না করলে সবসময় থেকে যায়।</p></li>
<li><p><strong>setTimeout(0) দিলে কি সাথে সাথে এক্সিকিউট হবে?</strong> - না। 0ms দিলেও Call Stack ফাঁকা না থাকলে অপেক্ষা করতে হবে। অনেক সময় 100ms পরেও হতে পারে।</p></li>
</ol>

<h3 id="observation-of-eventloop-callback-queue--microtask-queue-gif"><a class="header-link" href="#observation-of-eventloop-callback-queue--microtask-queue-gif"></a>Observation of Eventloop, Callback Queue & Microtask Queue [<strong>GIF</strong>]</h3>
<p><img src="./images/microtask1.gif" alt="microtask 1 Demo">
<img src="./images/microtask2.gif" alt="microtask 2 Demo">
<img src="./images/microtask3.gif" alt="microtask 3 Demo">
<img src="./images/microtask4.gif" alt="microtask 4 Demo">
<img src="./images/microtask5.gif" alt="microtask 5 Demo">
<img src="./images/microtask6.gif" alt="microtask 6 Demo"></p>
<hr>

<p>লাইভ দেখতে পারো ইউটিউবে:</p>
<p><a href="https://www.youtube.com/watch?v=8zKuNo4ay8E&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/8zKuNo4ay8E/0.jpg" width="750"
alt="Asynchronous JavaScript & EVENT LOOP from scratch in JS Youtube Link"/></a></p>
<br>

<hr>

<br>

<h1 id="episode-16--js-engine-exposed-googles-v8-architecture"><a class="header-link" href="#episode-16--js-engine-exposed-googles-v8-architecture"></a>Episode 16 : JS Engine Exposed, Google’s V8 Architecture</h1>
<ul class="list">
<li><p>JS আজকাল স্মার্ট ওয়াচ থেকে ব্রাউজার পর্যন্ত সবখানেই চলে কারণ আছে Javascript Runtime Environment (JRE)।</p></li>
<li><p>JRE হলো একটা বড় কন্টেইনার, যেখানে JS কোড রান করার জন্য সবকিছু আছে।</p></li>
<li><p>JRE এর ভেতরে আছে JS Engine (JRE-এর ❤️), APIs, Event loop, Callback Queue, Microtask Queue ইত্যাদি।</p></li>
<li><p>ব্রাউজার JS রান করতে পারে কারণ এর ভেতরে JRE আছে।</p></li>
<li><p>ECMAScript হলো JS এর নিয়ম বানানো সংগঠন। সব JS Engine (যেমন Chakra, V8, SpiderMonkey) এগুলো ফলো করে।</p></li>
<li><p>Javascript Engine কোনো মেশিন না, বরং সফটওয়্যার (C++ এ লেখা) যেটা High-level কোডকে Low-level Machine Code এ কনভার্ট করে।</p></li>
<li><p>JS Engine কোডকে ৩ ধাপে প্রসেস করে: <strong>Parsing</strong>, <strong>Compilation</strong>, <strong>Execution</strong></p>




<ol class="list">
<li><strong>Parsing</strong> - কোডকে ছোট ছোট টোকেনে ভাগ করা হয়। যেমন "let a = 7" → let, a, =, 7 এগুলো সব টোকেন। এছাড়াও আমাদের কাছে একটি syntax parser থাকে যা কোড নিয়ে সেটাকে AST (Abstract Syntax Tree) তে কনভার্ট করে। এটা একধরনের JSON যেখানে type, start, end, body ইত্যাদি key-value থাকে (দেখতে অনেকটা package.json এর মতো, তবে JS কোডের এক লাইনের জন্য)। (একটু তেমন জরুরি না)। (দেখতে পারো astexplorer.net → কোডের লাইনকে AST তে কনভার্ট করে)।</li>

<li><strong>Compilation</strong> - জাভাস্ক্রিপ্টে একটি জিনিস আছে যাকে বলে Just-in-time (JIT) Compilation — যেটা interpreter আর compiler দুটোই ব্যবহার করে। এখানে compilation আর execution একসাথে হয়। আগের ধাপ থেকে পাওয়া AST interpreter এর কাছে যায়, যেটা high-level কোডকে byte code এ কনভার্ট করে এবং execution এ পাঠায়। Interpreter কাজ করার সময় compiler ও runtime এ optimized কোড বানাতে সাহায্য করে। <strong>JavaScript কি সত্যিই Compile হয়?</strong> এর উত্তর হলো জোরে <strong>YES</strong> ✅। আরও তথ্য পাবে এখানে: <a href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/get-started/ch1.md#whats-in-an-interpretation">Link 1</a>, <a href="https://web.stanford.edu/class/cs98si/slides/overview.html">Link 2</a>, <a href="https://blog.greenroots.info/javascript-interpreted-or-compiled-the-debate-is-over-ckb092cv302mtl6s17t14hq1j">Link 3</a>। আগে JS শুধু interpreter ছিল, কিন্তু এখন এটা interpreter আর compiler দুটোই ব্যবহার করে এবং এজন্য JS কে JIT compiled language বলা হয় — মানে দুই দুনিয়ার সেরা।</li>

<li><strong>Execution</strong> - এর জন্য ২টা কম্পোনেন্ট দরকার 👉 Memory Heap (যেখানে সব মেমরি রাখা হয়) আর Call Stack (আগের episode এ যে call stack ছিল সেটাই)। এর সাথে একটি garbage collector থাকে। এটা <strong>Mark and Sweep</strong> নামের algorithm ব্যবহার করে।
<img src="./images/jsengine.jpg" alt="JS Engine Demo">
GiF Demo
<img src="./images/jsenginegif.gif" alt="JS Engine Demo"></li>
</ol>
</li>

<li><p>বিভিন্ন কোম্পানি বিভিন্ন JS Engine ব্যবহার করে এবং প্রত্যেকে তাদেরটা সেরা করার চেষ্টা করে।</p>
<ul class="list">
<li>Google এর v8 এ আছে Ignition (Interpreter), Turbo Fan (Compiler) এবং Orinoco (Garbage Collector)</li>
<li>v8 architecture:
<img src="./images/jsengine.png" alt="JS Engine Demo"></li>
</ul>
</li>

</ul>
<hr>

<p>লাইভ দেখতে পারো ইউটিউবে:</p>
<p><a href="https://www.youtube.com/watch?v=2WJL19wDH68&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/2WJL19wDH68/0.jpg" width="750"
alt="JS Engine Exposed, Google’s V8 Architecture in JS Youtube Link"/></a></p>
<br>

<hr>

<br>

<h1 id="episode-17--trust-issues-with-settimeout"><a class="header-link" href="#episode-17--trust-issues-with-settimeout"></a>Episode 17 : Trust issues with setTimeout()</h1>
<ul class="list">
<li><p>setTimeout(5000) দিলেও এক্সাক্ট ৫ সেকেন্ড পরে রান হবে তার কোনো গ্যারান্টি নেই। কখনো ৬, ৭ এমনকি ১০ সেকেন্ডও লাগতে পারে।</p></li>
<li><p>উদাহরণ:</p>
<pre class="prettyprint">console.log("Start");
setTimeout(function cb() {
  console.log("Callback");
}, 5000);
console.log("End");
// Millions of lines of code to execute

// o/p: Over here setTimeout exactly doesn't guarantee that the callback function will be called exactly after 5s. Maybe 6,7 or even 10! It all depends on callstack. Why?
</pre>
</li>
<li><p>কারণ:</p>
<ul class="list">
<li>প্রথমে GEC (Global Execution Context) তৈরি হয় এবং Call Stack-এ push করা হয়।</li>
<li>Console-এ "Start" প্রিন্ট হয়।</li>
<li>যখন setTimeout দেখা যায়, callback function টা Web API environment এ register হয়। এর সাথে timer attach হয়ে start হয়। Timer শেষ হলে callback execution-এর জন্য অপেক্ষা করে। কিন্তু JS কারো জন্য অপেক্ষা করে না, পরের লাইনে চলে যায়।</li>
<li>Console-এ "End" প্রিন্ট হয়।</li>
<li>"End" এর পরে ধরো ১০ সেকেন্ড লাগবে এমন ১ মিলিয়ন লাইনের কোড আছে। তাই GEC Stack থেকে pop হবে না, ১০ সেকেন্ড ধরে ওই কোড execute হবে।</li>
<li>কিন্তু ব্যাকগ্রাউন্ডে timer ৫ সেকেন্ডেই শেষ হয়ে গেছে। Timer শেষ হওয়ার সাথে সাথে callback function Callback Queue-তে চলে গেছে এবং Call Stack-এ push হওয়ার জন্য অপেক্ষা করছে।</li>
<li>Event Loop বারবার চেক করে Call Stack ফাঁকা কি না। কিন্তু এখানে এখনো GEC Stack-এ আছে, তাই Callback Queue থেকে Call Stack-এ আসতে পারছে না। <strong>তাই setTimeout ৫ সেকেন্ডের হলেও, Call Stack ফাঁকা না হওয়া পর্যন্ত (মানে ১০ সেকেন্ড পর) callback execute হবে।</strong> (GEC pop হওয়ার সাথে সাথেই callback Call Stack-এ push হয়ে সাথে সাথেই execute হয়।)</li>
<li>এটাই JS-এর <strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">Concurrency model</a></strong> নামে পরিচিত। এটাই setTimeout-এর “trust issue”-এর আসল কারণ।</li>
</ul>
</li>
<li><p>JavaScript এর প্রথম নিয়ম: <strong>main thread ব্লক করা যাবে না</strong> (কারণ JS একটি single-threaded (শুধু ১টা callstack) ভাষা)।</p>
</li>
<li><p>নিচের উদাহরণে, আমরা main thread ব্লক করছি। প্রশ্ন আর আউটপুট লক্ষ্য করো।
<img src="./images/settimeout1.jpg" alt="setTimeout Demo"></p>
</li>
<li><p>setTimeout গ্যারান্টি দেয় যে অন্তত নির্দিষ্ট টাইমার সময় শেষ হলেই কোড execute হবে।</p>
</li>
<li><p>JS একটি synchronous single-threaded ভাষা। শুধু ১টা thread দিয়েই সে সব কোড চালায়। এর ফলে JS অনেকটা interpreter ভাষার মতো কাজ করে এবং ব্রাউজারের ভেতরে খুব দ্রুত কোড execute হয় (compilation এর জন্য অপেক্ষা করতে হয় না) (JIT - Just in time compilation)। তবুও async কাজ করারও আলাদা উপায় আছে।</p>
</li>
<li><p>যদি <strong>timeout = 0sec</strong> হয় তাহলে?</p>
<pre class="prettyprint">console.log("Start");
setTimeout(function cb() {
  console.log("Callback");
}, 0);
console.log("End");
// Even though timer = 0s, the cb() has to go through the queue. Registers calback in webapi's env , moves to callback queue, and execute once callstack is empty.
// O/p - Start End Callback
// This method of putting timer = 0, can be used to defer a less imp function by a little so the more important function(here printing "End") can take place
</pre>
</li>
</ul>
<hr>

<p>লাইভ দেখতে পারো ইউটিউবে:</p>
<p><a href="https://www.youtube.com/watch?v=nqsPmuicJJc&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/nqsPmuicJJc/0.jpg" width="750"
alt="Trust issues with setTimeout() in JS Youtube Link"/></a></p>
<br>

<hr>

<br>


<h1 id="episode-18--higher-order-functions-ft-functional-programming"><a class="header-link" href="#episode-18--higher-order-functions-ft-functional-programming"></a>Episode 18 : Higher-Order Functions ft. Functional Programming</h1>

<h3 id="q-what-is-higher-order-function"><a class="header-link" href="#q-what-is-higher-order-function"></a>Q: What is Higher Order Function?</h3>

<p><strong>উত্তর</strong>: Higher-order functions হলো সাধারণ ফাংশন, যেগুলো অন্য ফাংশনকে আর্গুমেন্ট হিসেবে নিতে পারে অথবা ফলাফল হিসেবে ফাংশন রিটার্ন করতে পারে। যেমন:</p>

<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hi)&quot;</span>;
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params">x</span>) </span>{
    x();
};
y(); <span class="hljs-comment">// Hi</span>
<span class="hljs-comment">// y একটি higher order function</span>
<span class="hljs-comment">// x একটি callback function</span></code></pre>

<p>চলো বুঝে নেওয়া যাক ইন্টারভিউতে কিভাবে এই ধরনের সমস্যার সমাধান করতে হবে।  
ধরো আমার কাছে একটা radius এর অ্যারে আছে এবং আমি এগুলো দিয়ে area বের করতে চাই এবং অ্যারেতে সংরক্ষণ করতে চাই।</p>

<p><strong>প্রথম পদ্ধতি:</strong></p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> radius = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">const</span> calculateArea = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">radius</span>) </span>{
  <span class="hljs-keyword">const</span> output = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; radius.length; i++) {
    output.push(<span class="hljs-built_in">Math</span>.PI * radius[i] * radius[i]);
  }
  <span class="hljs-keyword">return</span> output;
};
<span class="hljs-built_in">console</span>.log(calculateArea(radius));</code></pre>

<p>এই সমাধানটা একদম ঠিকঠাক কাজ করছে, কিন্তু এবার যদি চাহিদা আসে circumference বের করার জন্য, তাহলে কোড হবে:</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> radius = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">const</span> calculateCircumference = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">radius</span>) </span>{
  <span class="hljs-keyword">const</span> output = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; radius.length; i++) {
    output.push(<span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI * radius[i]);
  }
  <span class="hljs-keyword">return</span> output;
};
<span class="hljs-built_in">console</span>.log(calculateCircumference(radius));</code></pre>

<p>কিন্তু এখানে আমরা DRY Principle ভঙ্গ করছি। এখন আরও ভালোভাবে করা যাক।</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> radiusArr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];

<span class="hljs-comment">// logic to calculate area</span>
<span class="hljs-keyword">const</span> area = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">radius</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI * radius * radius;
}

<span class="hljs-comment">// logic to calculate circumference</span>
<span class="hljs-keyword">const</span> circumference = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">radius</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI * radius;
}

<span class="hljs-keyword">const</span> calculate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">radiusArr, operation</span>) </span>{
    <span class="hljs-keyword">const</span> output = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; radiusArr.length; i++) {
        output.push(operation(radiusArr[i]));
    }
    <span class="hljs-keyword">return</span> output;
}
<span class="hljs-built_in">console</span>.log(calculate(radiusArr, area));
<span class="hljs-built_in">console</span>.log(calculate(radiusArr, circumference));
<span class="hljs-comment">// Over here calculate is HOF</span>
<span class="hljs-comment">// Over here we have extracted logic into separate functions. This is the beauty of functional programming.</span>

Polyfill <span class="hljs-keyword">of</span> map
<span class="hljs-comment">// Over here calculate is nothing but polyfill of map function</span>
<span class="hljs-comment">// console.log(radiusArr.map(area)) == console.log(calculate(radiusArr, area));</span>

***************************************************
Lets convert above calculate <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">as</span> <span class="hljs-title">map</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">and</span> <span class="hljs-title">try</span> <span class="hljs-title">to</span> <span class="hljs-title">use</span>. <span class="hljs-title">So</span>,

<span class="hljs-title">Array</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">calculate</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">operation</span>) </span>{
    <span class="hljs-title">const</span> <span class="hljs-title">output</span> = []</span>;
    <span class="hljs-title">for</span> (<span class="hljs-params"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++</span>) </span>{
        output.push(operation(<span class="hljs-built_in">this</span>[i]));
    }
    <span class="hljs-keyword">return</span> output;
}
<span class="hljs-built_in">console</span>.log(radiusArr.calculate(area))</code></pre>

<hr>

<p>লাইভ দেখো ইউটিউবে নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=HkWxvB1RJq0&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/HkWxvB1RJq0/0.jpg" width="750"
alt="Higher-Order Functions ft. Functional Programming in JS Youtube Link"/></a></p>
<br>
<hr>
<br>


<h1 id="episode-19--map-filter--reduce"><a class="header-link" href="#episode-19--map-filter--reduce"></a>Episode 19 : map, filter &amp; reduce</h1>
<blockquote>
<p>map, filter &amp; reduce হলো Higher Order Functions।</p>
</blockquote>

<h2 id="map-function"><a class="header-link" href="#map-function"></a>Map function</h2>
<p>এটা মূলত একটি array কে পরিবর্তন করার জন্য ব্যবহার করা হয়। map() মেথড একটি নতুন array তৈরি করে, যেখানে প্রতিটি element এর উপর একটি function চালিয়ে তার ফলাফল রাখা হয়।</p>
<p>const output = arr.map(<em>function</em>) // এখানে <em>function</em> map কে বলে দেয় প্রতিটি element এর উপর কী transformation হবে</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];
<span class="hljs-comment">// Task 1: Double the array element: [10, 2, 6, 4, 12]</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">double</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>;
}
<span class="hljs-keyword">const</span> doubleArr = arr.map(double); <span class="hljs-comment">// Internally map will run double function for each element of array and create a new array and returns it.</span>
<span class="hljs-built_in">console</span>.log(doubleArr); <span class="hljs-comment">// [10, 2, 6, 4, 12]</span></code></pre><pre class="hljs"><code><span class="hljs-comment">// Task 2: Triple the array element</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];
<span class="hljs-comment">// Transformation logic</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">triple</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> x * <span class="hljs-number">3</span>;
}
<span class="hljs-keyword">const</span> tripleArr = arr.map(triple);
<span class="hljs-built_in">console</span>.log(tripleArr); <span class="hljs-comment">// [15, 3, 9, 6, 18]</span></code></pre><pre class="hljs"><code><span class="hljs-comment">// Task 3: Convert array elements to binary</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];
<span class="hljs-comment">// Transformation logic:</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binary</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x.toString(<span class="hljs-number">2</span>);
}
<span class="hljs-keyword">const</span> binaryArr = arr.map(binary);

<span class="hljs-comment">// The above code can be rewritten as :</span>
<span class="hljs-keyword">const</span> binaryArr = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binary</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x.toString(<span class="hljs-number">2</span>);
}

<span class="hljs-comment">// OR -&gt; Arrow function</span>
<span class="hljs-keyword">const</span> binaryArr = arr.map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.toString(<span class="hljs-number">2</span>));</code></pre>

<p>অর্থাৎ map function প্রতিটি value কে traverse করে নির্দিষ্ট condition অনুযায়ী transform করে নতুন array return করে।</p>

<h2 id="filter-function"><a class="header-link" href="#filter-function"></a>Filter function</h2>
<p>Filter function array এর ভেতরের value গুলোকে ফিল্টার করতে ব্যবহার হয়। arr.filter() একটি নতুন array তৈরি করে, যেখানে শুধুমাত্র সেইসব element থাকে যেগুলো condition true করে।</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> array = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];
<span class="hljs-comment">// filter odd values</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isOdd</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span>;
}
<span class="hljs-keyword">const</span> oddArr = array.filter(isOdd); <span class="hljs-comment">// [5,1,3]</span>

<span class="hljs-comment">// Other way of writing the above:</span>
<span class="hljs-keyword">const</span> oddArr = arr.filter(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x % <span class="hljs-number">2</span>);</code></pre>

<p>Filter function শুধুমাত্র সেই value গুলোকে রাখে যেগুলো condition অনুযায়ী true হয়।</p>

<h2 id="reduce-function"><a class="header-link" href="#reduce-function"></a>Reduce function</h2>
<p>Reduce function array এর সব value কে নিয়ে একটি single output দেয়। এটি array কে reduce করে একটিমাত্র মানে পরিণত করে।</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> array = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];
<span class="hljs-comment">// Calculate sum of elements of array - Non functional programming way</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSum</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    sum = sum + arr[i];
  }
  <span class="hljs-keyword">return</span> sum;
}
<span class="hljs-built_in">console</span>.log(findSum(array)); <span class="hljs-comment">// 17</span>

<span class="hljs-comment">// reduce function way</span>
<span class="hljs-keyword">const</span> sumOfElem = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">accumulator, current</span>) </span>{
  <span class="hljs-comment">// current represent the value of array</span>
  <span class="hljs-comment">// accumulator is used the result from element of array.</span>
  <span class="hljs-comment">// In comparison to previous code snippet, *sum* variable is *accumulator* and *arr[i]* is *current*</span>
  accumulator = accumulator + current;
  <span class="hljs-keyword">return</span> accumulator;
}, <span class="hljs-number">0</span>); <span class="hljs-comment">//In above example sum was initialized with 0, so over here accumulator also needs to be initialized, so the second argument to reduce function represent the initialization value.</span>
<span class="hljs-built_in">console</span>.log(sumOfElem); <span class="hljs-comment">// 17</span></code></pre><pre class="hljs"><code><span class="hljs-comment">// find max inside array: Non functional programming way:</span>
<span class="hljs-keyword">const</span> array = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findMax</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++ {
        <span class="hljs-keyword">if</span> (arr[i] &gt; max) {
            max = arr[i]
        }
    }
    <span class="hljs-keyword">return</span> max;
}
<span class="hljs-built_in">console</span>.log(findMax(array)); <span class="hljs-comment">// 6</span>

<span class="hljs-comment">// using reduce</span>
<span class="hljs-keyword">const</span> output = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, current</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (current &gt; acc ) {
        acc = current;
    }
    <span class="hljs-keyword">return</span> acc;
}, <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(output); <span class="hljs-comment">// 6</span>

<span class="hljs-comment">// acc is just a label which represent the accumulated value till now,</span>
<span class="hljs-comment">// so we can also label it as max in this case</span>
<span class="hljs-keyword">const</span> output = arr.reduce(<span class="hljs-function">(<span class="hljs-params">max, current</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (current &gt; max) {
        max= current;
    }
    <span class="hljs-keyword">return</span> max;
}, <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(output); <span class="hljs-comment">// 6</span></code></pre>

<h2 id="tricky-map"><a class="header-link" href="#tricky-map"></a>Tricky MAP</h2>
<pre class="hljs"><code><span class="hljs-keyword">const</span> users = [
    { <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Alok&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Raj&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span> },
    { <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Ashish&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Kumar&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">29</span> },
    { <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Ankit&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Roy&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">29</span> },
    { <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Pranav&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Mukherjee&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">50</span> },
];
<span class="hljs-comment">// Get array of full name : [&quot;Alok Raj&quot;, &quot;Ashish Kumar&quot;, ...]</span>
<span class="hljs-keyword">const</span> fullNameArr = users.map(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.firstName + <span class="hljs-string">&quot; &quot;</span> + user.lastName);
<span class="hljs-built_in">console</span>.log(fullNameArr); <span class="hljs-comment">// [&quot;Alok Raj&quot;, &quot;Ashish Kumar&quot;, ...]</span>

----------------------------------------------------------

<span class="hljs-comment">// Get the count/report of how many unique people with unique age are there</span>
<span class="hljs-comment">// like: {29 : 2, 75 : 1, 50 : 1}</span>
<span class="hljs-comment">// We should use reduce, why? we want to deduce some information from the array. Basically we want to get a single object as output</span>
<span class="hljs-keyword">const</span> report = users.reduce(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span>(acc[curr.age]) {
        acc[curr.age] = ++ acc[curr.age] ;
    } <span class="hljs-keyword">else</span> {
        acc[curr.age] = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> acc;  <span class="hljs-comment">//to every time return update object</span>
}, {})
<span class="hljs-built_in">console</span>.log(report) <span class="hljs-comment">// {29 : 2, 75 : 1, 50 : 1}</span></code></pre>

<h2 id="function-chaining"><a class="header-link" href="#function-chaining"></a>Function Chaining</h2>
<pre class="hljs"><code><span class="hljs-comment">// First name of all people whose age is less than 30</span>
<span class="hljs-keyword">const</span> users = [
  { <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Alok&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Raj&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span> },
  { <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Ashish&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Kumar&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">29</span> },
  { <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Ankit&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Roy&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">29</span> },
  { <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Pranav&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Mukherjee&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">50</span> },
];

<span class="hljs-comment">// function chaining</span>
<span class="hljs-keyword">const</span> output = users
  .filter(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.age &lt; <span class="hljs-number">30</span>)
  .map(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.firstName);
<span class="hljs-built_in">console</span>.log(output); <span class="hljs-comment">// [&quot;Alok&quot;, &quot;Ashish&quot;, &quot;Ankit&quot;]</span>

<span class="hljs-comment">// Homework challenge: Implement the same logic using reduce</span>
<span class="hljs-keyword">const</span> output = users.reduce(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (curr.age &lt; <span class="hljs-number">30</span>) {
    acc.push(curr.firstName);
  }
  <span class="hljs-keyword">return</span> acc;
}, []);
<span class="hljs-built_in">console</span>.log(output); <span class="hljs-comment">// [&quot;Alok&quot;, &quot;Ashish&quot;, &quot;Ankit&quot;]</span></code></pre>

<hr>
<p>Youtube এ Live দেখো নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=zdp0zrpKzIE&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP" target="_blank"><img src="https://img.youtube.com/vi/zdp0zrpKzIE/0.jpg" width="750"
alt="map, filter & reduce Youtube Link"/></a></p>
<br>
<hr>








<br>

<h1 id="episode-20--callback"><a class="header-link" href="#episode-20--callback"></a>Episode 20 : Callback</h1>

<ul class="list">
<li><p>Callback এর ২টা অংশ আছে:</p>
<ol class="list">
<li>ভালো দিক → Callback asynchronous code লেখার সময় অনেক গুরুত্বপূর্ণ।</li>
<li>খারাপ দিক → Callback ব্যবহারে আমরা কিছু সমস্যার মুখোমুখি হই:
<ul class="list">
<li>Callback Hell</li>
<li>Inversion of Control</li>
</ul>
</li>
</ol>
</li>
<li><p>Callback এর খারাপ দিকগুলো ভালোভাবে বুঝতে হবে, কারণ পরবর্তী lecture এ Promise শেখার জন্য এগুলো গুরুত্বপূর্ণ।</p></li>
</ul>

<blockquote>
<p>💡 JavaScript হলো synchronous, single threaded language। এক সময়ে একটাই কাজ করতে পারে। JS Engine আমাদের দেয়া code গুলো দ্রুত execute করে, এটি অপেক্ষা করে না।</p>
</blockquote>

<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Namaste&quot;</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;JavaScript&quot;</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Season 2&quot;</span>);
<span class="hljs-comment">// Namaste</span>
<span class="hljs-comment">// JavaScript</span>
<span class="hljs-comment">// Season 2</span>

<span class="hljs-comment">// 💡 It is quickly printing because `Time, tide &amp; Javascript waits for none.`</span></code></pre>

<p><em>কিন্তু যদি execution delay করতে চাই, তখন callback কাজে আসে।</em></p>

<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Namaste&quot;</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;JavaScript&quot;</span>);
}, <span class="hljs-number">5000</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Season 2&quot;</span>);
<span class="hljs-comment">// Namaste</span>
<span class="hljs-comment">// Season 2</span>
<span class="hljs-comment">// JavaScript</span>

<span class="hljs-comment">// 💡 Here we are delaying the execution using callback approach of setTimeout.</span></code></pre>

<h3 id="🛒-e-commerce-web-app-situation"><a class="header-link" href="#🛒-e-commerce-web-app-situation"></a>🛒 e-Commerce web app উদাহরণ</h3>

<p>ধরা যাক একজন ইউজার order দিচ্ছে। তার cart এ আছে shoes, pants, kurta। order place করার জন্য backend এ কোড এরকম হতে পারে:</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> cart = [<span class="hljs-string">&quot;shoes&quot;</span>, <span class="hljs-string">&quot;pants&quot;</span>, <span class="hljs-string">&quot;kurta&quot;</span>];
<span class="hljs-comment">// Two steps to place a order</span>
<span class="hljs-comment">// 1. Create a Order</span>
<span class="hljs-comment">// 2. Proceed to Payment</span>

<span class="hljs-comment">// It could look something like this:</span>
api.createOrder();
api.proceedToPayment();</code></pre>
















<p>ধরা যাক, একবার order তৈরি হলে তবেই আমরা payment এ যেতে পারব, মানে এখানে একটা dependency আছে। তাহলে কিভাবে এই dependency ম্যানেজ করা যায়?
Callback আমাদের সাহায্য করতে পারে, কিভাবে?</p>

<pre class="hljs"><code>api.createOrder(cart, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  api.proceedToPayment();
});
<span class="hljs-comment">// 💡 Over here `createOrder` api is first creating a order then it is responsible to call `api.proceedToPayment()` as part of callback approach.</span></code></pre>

<p>এবার একটু জটিল করি — যদি payment শেষ হওয়ার পর Order summary দেখাতে হয় <code>api.showOrderSummary()</code> দিয়ে, আর এখন তার dependency হলো <code>api.proceedToPayment()</code> এর উপর।
এক্ষেত্রে আমাদের কোডটা কিছুটা এমন হবে:</p>

<pre class="hljs"><code>api.createOrder(cart, function () {
  api.proceedToPayment(function () {
    api.showOrderSummary();
  });
});
</code></pre>

<p>এখন ধরো আমাদের wallet update করতে হবে, যেটা আবার <code>showOrderSummary</code> এর উপর dependent।</p>

<pre class="hljs"><code>api.createOrder(cart, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  api.proceedToPayment(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    api.showOrderSummary(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      api.updateWallet();
    });
  });
});
<span class="hljs-comment">// 💡 Callback Hell</span></code></pre>

<p>যখন বড় কোডবেসে একাধিক API একে অপরের উপর নির্ভরশীল হয়, তখন আমরা Callback Hell এ পড়ে যাই। 
এমন কোড maintain করা খুব কঠিন হয়ে যায়।  
এই callback hell structure কেই বলা হয় <strong>Pyramid of Doom</strong>.</p>

<p>এ পর্যন্ত আমরা callback hell এর কনসেপ্ট বুঝেছি। এবার আসি <code>Inversion of Control</code> এ। Promise ভালোভাবে বুঝতে এটা জানা খুব দরকার।</p>

<blockquote>
<p>💡 Inversion of control মানে callback ব্যবহার করার সময় আমরা আমাদের কোডের control হারিয়ে ফেলি।</p>
</blockquote>

<p>চল একটা উদাহরণ দিয়ে বোঝা যাক:</p>

<pre class="hljs"><code>api.createOrder(cart, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  api.proceedToPayment();
});

<span class="hljs-comment">// 💡 So over here, we are creating a order and then we are blindly trusting `createOrder` to call `proceedToPayment`.</span>

<span class="hljs-comment">// 💡 It is risky, as `proceedToPayment` is important part of code and we are blindly trusting `createOrder` to call it and handle it.</span>

<span class="hljs-comment">// 💡 When we pass a function as a callback, basically we are dependant on our parent function that it is his responsibility to run that function. This is called `inversion of control` because we are dependant on that function. What if parent function stopped working, what if it was developed by another programmer or callback runs two times or never run at all.</span>

<span class="hljs-comment">// 💡 In next session, we will see how we can fix such problems.</span></code></pre>

<blockquote>
<p>💡 JavaScript এ async programming এর অস্তিত্বই callback এর কারণে।</p>
</blockquote>

<p>আরও জানো এখানে: <code>http://callbackhell.com/</code></p>

<p>Live দেখো YouTube এ নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=yEKtJGha3yM&list=PLlasXeu85E9eWOpw9jxHOQyGMRiBZ60aX" target="_blank"><img src="https://img.youtube.com/vi/yEKtJGha3yM/0.jpg" width="750"
alt="map, filter & reduce Youtube Link"/></a></p>

<br><hr>

<h1 id="episode-21--promises"><a class="header-link" href="#episode-21--promises"></a>Episode 21 : Promises</h1>

<blockquote>
<p>Promises ব্যবহার করা হয় JavaScript এ asynchronous operations handle করার জন্য।</p>
</blockquote>

<p>আমরা কোড উদাহরণ দিয়ে আলোচনা করব আগে কিভাবে কাজ হতো <code>Promises</code> ছাড়া আর পরে কিভাবে কাজ হয় <code>Promises</code> দিয়ে।</p>

<p>ধরা যাক, একটা E-Commerce এর example:</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> cart = [<span class="hljs-string">"shoes"</span>, <span class="hljs-string">"pants"</span>, <span class="hljs-string">"kurta"</span>];

<span class="hljs-comment">// Below two functions are asynchronous and dependent on each other</span>
<span class="hljs-keyword">const</span> orderId = createOrder(cart);
proceedToPayment(orderId);

<span class="hljs-comment">// with Callback (Before Promise)</span>
<span class="hljs-comment">// Below here, it is the responsibility of createOrder function to first create the order then call the callback function</span>
createOrder(cart, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  proceedToPayment(orderId);
});
<span class="hljs-comment">// Above there is the issue of `Inversion of Control`</span></code></pre>

<p>প্রশ্ন: উপরের সমস্যাটা কিভাবে fix করা যায়?<br><em>উত্তর: Promise ব্যবহার করে।</em></p>

<p>এখন আমরা <code>createOrder</code> ফাংশনটিকে এমনভাবে বানাবো যাতে সেটা একটি promise রিটার্ন করে এবং আমরা সেই <code>promise</code> টিকে একটি <code>variable</code> এ ক্যাপচার করব।</p>
<p>Promise আসলে কিছু নয়, এটাকে তুমি একটি ফাঁকা object হিসাবে ধরতে পারো যার মধ্যে data value থাকবে। আর এই data value তে <code>createOrder</code> ফাংশন যা return করবে তাই থাকবে।</p>
<p>কারণ <code>createOrder</code> ফাংশনটি asynchronous এবং আমরা জানি না এটি এক্সিকিউশন শেষ করতে কত সময় নেবে।</p>
<p>তাহলে <code>createOrder</code> এক্সিকিউট হওয়ার সাথে সাথেই এটি তোমাকে একটি <code>undefined</code> ভ্যালু রিটার্ন করবে। ধরা যাক ৫ সেকেন্ড পরে এক্সিকিউশন শেষ হলো এবং <code>orderId</code> প্রস্তুত হলো, তখন সেই <code>undefined</code> জায়গায় <code>orderId</code> ভরে যাবে।</p>
<p>সংক্ষেপে, যখন <code>createOrder</code> এক্সিকিউট হয়, তখনই এটি একটি <code>promise object</code> রিটার্ন করে যেটির ভ্যালু শুরুতে <code>undefined</code> থাকে। তারপর জাভাস্ক্রিপ্ট অন্য লাইনগুলো এক্সিকিউট করতে থাকে। কিছুক্ষণ পর যখন <code>createOrder</code> এর কাজ শেষ হয় এবং <code>orderId</code> তৈরি হয়, তখন সেটি স্বয়ংক্রিয়ভাবে সেই <code>promise</code> এ অ্যাসাইন হয়ে যায় যেটি আগে <code>undefined</code> ছিল।</p>
<p>❓ প্রশ্ন: আমরা কীভাবে জানব response রেডি হয়েছে?<br><em>✅ উত্তর: আমরা promise object এর সাথে একটি <code>callback</code> অ্যাটাচ করব <code>then</code> ব্যবহার করে, যেটি ডেটা রেডি হলে অটোমেটিক ট্রিগার হবে।</em></p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> cart = [<span class="hljs-string">&quot;shoes&quot;</span>, <span class="hljs-string">&quot;pants&quot;</span>, <span class="hljs-string">&quot;kurta&quot;</span>];

<span class="hljs-keyword">const</span> promiseRef = createOrder(cart);
<span class="hljs-comment">// this promiseRef has access to `then`</span>

<span class="hljs-comment">// {data: undefined}</span>
<span class="hljs-comment">// Initially it will be undefined so below code won&#x27;t trigger</span>
<span class="hljs-comment">// After some time, when execution has finished and promiseRef has the data then automatically the below line will get triggered.</span>

promiseRef.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  proceedToPayment(orderId);
});</code></pre>

<p>❓ প্রশ্ন: এটা callback approach থেকে কিভাবে ভালো?</p>
<p>আগের সমাধানে আমরা ফাংশনটা পাস করতাম এবং তারপর ভরসা করতাম সেই ফাংশন callback এক্সিকিউট করবে।</p>
<p>কিন্তু promise এর ক্ষেত্রে আমরা একটি callback ফাংশন promiseObject এর সাথে attach করি।</p>
<p>ফারাক হলো, একটা ফাংশন pass করা আর একটা ফাংশন attach করার মধ্যে।</p>
<p>Promise গ্যারান্টি দেয় যে, যখন ডেটা available হবে তখন এটি একবারই callback কল করবে। শুধু একবারই।</p>
<p>আগে আমরা বলেছিলাম promise হলো একটা ফাঁকা অবজেক্ট কিন্তু আসলে promise তার চেয়েও বেশি কিছু।</p>
<p>এবার চল আমরা একটি বাস্তব promise object দেখি।</p>
<p><code>fetch</code> হলো একটি web-api যেটি api কল করার জন্য ব্যবহৃত হয় এবং এটি একটি promise রিটার্ন করে।</p>
<p>আমরা এখানে পাবলিক github api কল করব ডেটা ফেচ করার জন্য<br>
<a href="https://api.github.com/users/alok722">https://api.github.com/users/alok722</a></p>

<pre class="hljs"><code><span class="hljs-comment">// We will be calling public github api to fetch data</span>
<span class="hljs-keyword">const</span> URL = <span class="hljs-string">&quot;https://api.github.com/users/alok722&quot;</span>;
<span class="hljs-keyword">const</span> user = fetch(URL);
<span class="hljs-comment">// User above will be a promise.</span>
<span class="hljs-built_in">console</span>.log(user); <span class="hljs-comment">// Promise {&lt;Pending&gt;}</span>

<span class="hljs-comment">/** OBSERVATIONS:
 * If we will deep dive and see, this `promise` object has 3 things
 * `prototype`, `promiseState` &amp; `promiseResult`
 * &amp; this `promiseResult` is the same data which we talked earlier as data
 * &amp; initially `promiseResult` is `undefined`
 *
 * `promiseResult` will store data returned from API call
 * `promiseState` will tell in which state the promise is currently, initially it will be in `pending` state and later it will become `fulfilled`
 */</span>

<span class="hljs-comment">/**
 * When above line is executed, `fetch` makes API call and return a `promise` instantly which is in `Pending` state and Javascript doesn&#x27;t wait to get it `fulfilled`
 * And in next line it console out the `pending promise`.
 * <span class="hljs-doctag">NOTE:</span> chrome browser has some in-consistency, the moment console happens it shows in pending state but if you will expand that it will show fulfilled because chrome updated the log when promise get fulfilled.
 * Once fulfilled data is there in promiseResult and it is inside body in ReadableStream format and there is a way to extract data.
 */</span></code></pre>

<p>এখন আমরা উপরোক্ত response এ callback attach করতে পারি?</p>
<p><code>.then</code> ব্যবহার করে:</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> URL = <span class="hljs-string">&quot;https://api.github.com/users/alok722&quot;</span>;
<span class="hljs-keyword">const</span> user = fetch(URL);

user.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
  <span class="hljs-built_in">console</span>.log(data);
});
<span class="hljs-comment">// And this is how Promise is used.</span>
<span class="hljs-comment">// It guarantees that it could be resolved only once, either it could be `success` or `failure`</span>
<span class="hljs-comment">/**
    A Promise is in one of these states:

    pending: initial state, neither fulfilled nor rejected.
    fulfilled: meaning that the operation was completed successfully.
    rejected: meaning that the operation failed.
 */</span></code></pre>

<p>💡 Promise Object গুলো immutable।<br>-&gt; একবার promise fulfilled হলে এবং ডেটা পাওয়া গেলে, তুমি সেটা এদিক ওদিক পাঠাতে পারো কিন্তু সেটা কেউ mutate করতে পারবে না। যেমন, আমরা সরাসরি <code>user</code> promise object mutate করতে পারব না, বরং আমাদের <code>.then</code> ব্যবহার করতে হবে।</p>

<h3 id="interview-guide"><a class="header-link" href="#interview-guide"></a>Interview Guide</h3>
<p>💡 Promise কী?<br>-&gt; Promise object হলো একটি placeholder, যতক্ষণ না পর্যন্ত আমরা asynchronous operation থেকে value পাই।</p>
<p>-&gt; এটা হলো ভবিষ্যতের কোনো ভ্যালুর container।</p>
<p>-&gt; <strong>A Promise is an object representing the eventual completion or failure of an asynchronous operation.</strong></p>
<p>আমরা এখন callback এর একটি সমস্যা fix করেছি যেটা হলো Inversion of Control।</p>
<p>কিন্তু আরেকটি সমস্যা আছে — callback hell...</p>

<pre class="hljs"><code><span class="hljs-comment">// Callback Hell Example</span>
createOrder(cart, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">orderId</span>) </span>{
  proceedToPayment(orderId, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">paymentInf</span>) </span>{
    showOrderSummary(paymentInf, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">balance</span>) </span>{
      updateWalletBalance(balance);
    });
  });
});
<span class="hljs-comment">// And now above code is expanding horizontally and this is called pyramid of doom.</span>
<span class="hljs-comment">// Callback hell is ugly and hard to maintain.</span>

<span class="hljs-comment">// 💡 Promise fixes this issue too using `Promise Chaining`</span>
<span class="hljs-comment">// Example Below is a Promise Chaining</span>
createOrder(cart)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">orderId</span>) </span>{
    proceedToPayment(orderId);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">paymentInf</span>) </span>{
    showOrderSummary(paymentInf);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">balance</span>) </span>{
    updateWalletBalance(balance);
  });

<span class="hljs-comment">// ⚠️ Common PitFall</span>
<span class="hljs-comment">// We forget to return promise in Promise Chaining</span>
<span class="hljs-comment">// The idea is promise/data returned from one .then become data for next .then</span>
<span class="hljs-comment">// So,</span>
createOrder(cart)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">orderId</span>) </span>{
    <span class="hljs-keyword">return</span> proceedToPayment(orderId);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">paymentInf</span>) </span>{
    <span class="hljs-keyword">return</span> showOrderSummary(paymentInf);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">balance</span>) </span>{
    <span class="hljs-keyword">return</span> updateWalletBalance(balance);
  });

<span class="hljs-comment">// To improve readability you can use arrow function instead of regular function</span></code></pre>
<hr>

<p>নীচে YouTube এ লাইভ দেখো:</p>
<p><a href="https://www.youtube.com/watch?v=ap-6PPAuK1Y&list=PLlasXeu85E9eWOpw9jxHOQyGMRiBZ60aX&index=3&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/ap-6PPAuK1Y/0.jpg" width="750"
alt="promise in Javascript Youtube Link"/></a></p>
<br>

<hr>

<h1 id="episode-22--creating-a-promise-chaining--error-handling"><a class="header-link" href="#episode-22--creating-a-promise-chaining--error-handling"></a>Episode 22 : Creating a Promise, Chaining &amp; Error Handling</h1>

<p>আমরা এখন শিখব কীভাবে একটি promise তৈরি করা যায়, কীভাবে সেটা ব্যবহার করা যায় এবং কীভাবে error handle করতে হয়।</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> cart = [<span class="hljs-string">"shoes"</span>, <span class="hljs-string">"pants"</span>, <span class="hljs-string">"kurta"</span>];

<span class="hljs-comment">// Consumer part of promise</span>
<span class="hljs-keyword">const</span> promise = createOrder(cart); <span class="hljs-comment">// orderId</span>
<span class="hljs-comment">// Our expectation is above function is going to return me a promise.</span>

promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">orderId</span>) </span>{
  proceedToPayment(orderId);
});

<span class="hljs-comment">// Above snippet we have observed in our previous lecture itself.</span>
<span class="hljs-comment">// Now we will see, how createOrder is implemented so that it is returning a promise</span>
<span class="hljs-comment">// In short we will see, "How we can create Promise" and then return it.</span>

<span class="hljs-comment">// Producer part of Promise</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createOrder</span>(<span class="hljs-params">cart</span>) </span>{
  <span class="hljs-comment">// JS provides a Promise constructor through which we can create promise</span>
  <span class="hljs-comment">// It accepts a callback function with two parameter `resolve` &amp; `reject`</span>
  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">// What is this `resolve` and `reject`?</span>
    <span class="hljs-comment">// These are function which are passed by javascript to us in order to handle success and failure of function call.</span>
    <span class="hljs-comment">// Now we will write logic to `createOrder`</span>
    <span class="hljs-comment">/** Mock logic steps
     * 1. validateCart
     * 2. Insert in DB and get an orderId
     */</span>
    <span class="hljs-comment">// We are assuming in real world scenario, validateCart would be defined</span>
    <span class="hljs-keyword">if</span> (!validateCart(cart)) {
      <span class="hljs-comment">// If cart not valid, reject the promise</span>
      <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cart is not Valid"</span>);
      reject(err);
    }
    <span class="hljs-keyword">const</span> orderId = <span class="hljs-string">"12345"</span>; <span class="hljs-comment">// We got this id by calling to db (Assumption)</span>
    <span class="hljs-keyword">if</span> (orderId) {
      <span class="hljs-comment">// Success scenario</span>
      resolve(orderId);
    }
  });
  <span class="hljs-keyword">return</span> promise;
}</code></pre>

<p>উপরের কোডে, যদি <code>validateCart</code> true রিটার্ন করে, তাহলে promise resolve হবে (success)।</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> cart = [<span class="hljs-string">"shoes"</span>, <span class="hljs-string">"pants"</span>, <span class="hljs-string">"kurta"</span>];

<span class="hljs-keyword">const</span> promise = createOrder(cart); <span class="hljs-comment">// orderId</span>
<span class="hljs-comment">// ❓ What will be printed in below line?</span>
<span class="hljs-comment">// It prints Promise {&lt;pending&gt;}, but why?</span>
<span class="hljs-comment">// Because above createOrder is going to take sometime to get resolved, so pending state. But once the promise is resolved, `.then` would be executed for callback.</span>
<span class="hljs-built_in">console</span>.log(promise);

promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">orderId</span>) </span>{
  proceedToPayment(orderId);
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createOrder</span>(<span class="hljs-params">cart</span>) </span>{
  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-keyword">if</span> (!validateCart(cart)) {
      <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cart is not Valid"</span>);
      reject(err);
    }
    <span class="hljs-keyword">const</span> orderId = <span class="hljs-string">"12345"</span>;
    <span class="hljs-keyword">if</span> (orderId) {
      resolve(orderId);
    }
  });
  <span class="hljs-keyword">return</span> promise;
}</code></pre>

<p>❓ প্রশ্ন: উপরের <code>console.log(promise)</code> লাইনে কী প্রিন্ট হবে?<br>
✅ উত্তর: <code>Promise {&lt;pending&gt;}</code> — কারণ promise resolve হতে কিছু সময় লাগে। একবার resolve হয়ে গেলে, <code>.then</code> callback এক্সিকিউট হবে।</p>

<p>এখন যদি কোনো error ঘটে এবং আমরা promise reject করি, তখন কিভাবে সেই error ধরব?<br>
👉 <code>.catch</code> ব্যবহার করে।</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> cart = [<span class="hljs-string">"shoes"</span>, <span class="hljs-string">"pants"</span>, <span class="hljs-string">"kurta"</span>];

<span class="hljs-keyword">const</span> promise = createOrder(cart); <span class="hljs-comment">// orderId</span>

<span class="hljs-comment">// Here we are consuming Promise and will try to catch promise error</span>
promise
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">orderId</span>) </span>{
    <span class="hljs-comment">// ✅ success aka resolved promise handling</span>
    proceedToPayment(orderId);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
    <span class="hljs-comment">// ⚠️ failure aka reject handling</span>
    <span class="hljs-built_in">console</span>.log(err);
  });

<span class="hljs-comment">// Here we are creating Promise</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createOrder</span>(<span class="hljs-params">cart</span>) </span>{
  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">// Assume below `validateCart` return false then the promise will be rejected</span>
    <span class="hljs-comment">// And then our browser is going to throw the error.</span>
    <span class="hljs-keyword">if</span> (!validateCart(cart)) {
      <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cart is not Valid"</span>);
      reject(err);
    }
    <span class="hljs-keyword">const</span> orderId = <span class="hljs-string">"12345"</span>;
    <span class="hljs-keyword">if</span> (orderId) {
      resolve(orderId);
    }
  });
  <span class="hljs-keyword">return</span> promise;
}</code></pre>

<p>এখন আমরা বুঝব <strong>Promise Chaining</strong> এর কনসেপ্ট।<br>
👉 এখানে আমরা ধরব যে <code>createOrder</code> এর পরে <code>proceedToPayment</code> কল করতে হবে।<br>
👉 Promise chaining এ, প্রথম <code>.then</code> থেকে যা রিটার্ন হয়, সেটা পরের <code>.then</code> এর input হয়, এভাবে চলতে থাকে।<br>
👉 কোনো পর্যায়ে যদি promise reject হয়, তাহলে execution সরাসরি <code>.catch</code> এ চলে যাবে এবং বাকি promise execute হবে না।</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> cart = [<span class="hljs-string">"shoes"</span>, <span class="hljs-string">"pants"</span>, <span class="hljs-string">"kurta"</span>];

createOrder(cart)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">orderId</span>) </span>{
    <span class="hljs-comment">// ✅ success aka resolved promise handling</span>
    <span class="hljs-comment">// 💡 we have return data or promise so that we can keep chaining the promises, here we are returning data</span>
    <span class="hljs-built_in">console</span>.log(orderId);
    <span class="hljs-keyword">return</span> orderId;
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">orderId</span>) </span>{
    <span class="hljs-comment">// Promise chaining</span>
    <span class="hljs-comment">// 💡 we will make sure that `proceedToPayment` returns a promise too</span>
    <span class="hljs-keyword">return</span> proceedToPayment(orderId);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">paymentInfo</span>) </span>{
    <span class="hljs-comment">// from above, `proceedToPayment` is returning a promise so we can consume using `.then`</span>
    <span class="hljs-built_in">console</span>.log(paymentInfo);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
    <span class="hljs-comment">// ⚠️ failure aka reject handling</span>
    <span class="hljs-built_in">console</span>.log(err);
  });

<span class="hljs-comment">// Here we are creating Promise</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createOrder</span>(<span class="hljs-params">cart</span>) </span>{
  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">// Assume below `validateCart` return false then the promise will be rejected</span>
    <span class="hljs-comment">// And then our browser is going to throw the error.</span>
    <span class="hljs-keyword">if</span> (!validateCart(cart)) {
      <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cart is not Valid"</span>);
      reject(err);
    }
    <span class="hljs-keyword">const</span> orderId = <span class="hljs-string">"12345"</span>;
    <span class="hljs-keyword">if</span> (orderId) {
      resolve(orderId);
    }
  });
  <span class="hljs-keyword">return</span> promise;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proceedToPayment</span>(<span class="hljs-params">cart</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">// For time being, we are simply `resolving` promise</span>
    resolve(<span class="hljs-string">"Payment Successful"</span>);
  });
}</code></pre>

<p>❓ প্রশ্ন: যদি আমরা চাই execution চলতে থাকুক এমনকি কোনো promise fail করলেও, সেটা কিভাবে করা যাবে?<br>
👉 নির্দিষ্ট কোনো লেভেলে <code>.catch</code> বসিয়ে দেওয়া যায়, যাতে তারপরে execution unaffected থাকে।<br>
👉 একাধিক <code>.catch</code> ও থাকতে পারে।</p>

<pre class="hljs"><code>createOrder(cart)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">orderId</span>) </span>{
    <span class="hljs-comment">// ✅ success aka resolved promise handling</span>
    <span class="hljs-comment">// 💡 we have return data or promise so that we can keep chaining the promises, here we are returning data</span>
    <span class="hljs-built_in">console</span>.log(orderId);
    <span class="hljs-keyword">return</span> orderId;
  })
    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
    <span class="hljs-comment">// ⚠️ Whatever fails below it, catch wont care</span>
    <span class="hljs-comment">// this block is responsible for code block above it.</span>
    <span class="hljs-built_in">console</span>.log(err);
  });
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">orderId</span>) </span>{
    <span class="hljs-comment">// Promise chaining</span>
    <span class="hljs-comment">// 💡 we will make sure that `proceedToPayment` returns a promise too</span>
    <span class="hljs-keyword">return</span> proceedToPayment(orderId);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">paymentInfo</span>) </span>{
    <span class="hljs-comment">// from above, `proceedToPayment` is returning a promise so we can consume using `.then`</span>
    <span class="hljs-built_in">console</span>.log(paymentInfo);
  })</code></pre>

<hr>

<p>নীচে YouTube এ লাইভ দেখো:</p>
<p><a href="https://www.youtube.com/watch?v=U74BJcr8NeQ&list=PLlasXeu85E9eWOpw9jxHOQyGMRiBZ60aX&index=4&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/U74BJcr8NeQ/0.jpg" width="750"
alt="promise in Javascript Youtube Link"/></a></p>
<br>

<hr>

<h1 id="episode-23--async-await"><a class="header-link" href="#episode-23--async-await"></a>Episode 23 : async await</h1>
<h3 id="-1"><a class="header-link" href="#-1"></a></h3>
<p>আলোচনার বিষয়বস্তু</p>
<ul class="list">
<li>async কী?</li>
<li>await কী?</li>
<li>async await কীভাবে কাজ করে ভেতরের দিক থেকে?</li>
<li>async/await ব্যবহারের উদাহরণ</li>
<li>এরর হ্যান্ডলিং</li>
<li>ইন্টারভিউ প্রসঙ্গ</li>
<li>Async await বনাম Promise.then/.catch</li>
</ul>
<p>প্রশ্ন: async কী?<br>উত্তর: async একটি কীওয়ার্ড যা কোনো ফাংশনের আগে ব্যবহার করা হয় তাকে async function বানানোর জন্য।</p>
<p>প্রশ্ন: async function কী এবং এটি সাধারণ ফাংশনের থেকে কীভাবে আলাদা?</p>

<pre class="hljs"><code><span class="hljs-comment">// 💡 async function always returns a promise, even if I return a simple string from below function, async keyword will wrap it under Promise and then return.</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Namaste JavaScript"</span>;
}
<span class="hljs-keyword">const</span> dataPromise = getData();
<span class="hljs-built_in">console</span>.log(dataPromise); <span class="hljs-comment">// Promise {&lt;fulfilled&gt;: 'Namaste JavaScript'}</span>

<span class="hljs-comment">//❓How to extract data from above promise? One way is using promise .then</span>
dataPromise.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(res)); <span class="hljs-comment">// Namaste JavaScript</span></code></pre>

<p>আরেকটি উদাহরণ যেখানে <code>async</code> function একটি Promise রিটার্ন করছে</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  resolve(<span class="hljs-string">"Promise resolved value!!"</span>);
});

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> p;
}
<span class="hljs-comment">// In above case, since we are already returning a promise async function would simply return that instead of wrapping with a new Promise.</span>
<span class="hljs-keyword">const</span> dataPromise = getData();
<span class="hljs-built_in">console</span>.log(dataPromise); <span class="hljs-comment">// Promise {&lt;fulfilled&gt;: 'Promise resolved value!!'}</span>
dataPromise.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(res)); <span class="hljs-comment">// Promise resolved value!!</span></code></pre>

<p>প্রশ্ন: কীভাবে আমরা <code>await</code> ব্যবহার করব async function এর সাথে?<br>উত্তর: <code>async</code> এবং <code>await</code> একসাথে ব্যবহার করা হয় promise হ্যান্ডল করার জন্য।</p>
<p>কিন্তু প্রশ্ন হলো, আগের দিনে আমরা কীভাবে promise হ্যান্ডল করতাম এবং কেন async/await দরকার?</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  resolve(<span class="hljs-string">"Promise resolved value!!"</span>);
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
  p.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(res));
}

getData(); <span class="hljs-comment">// Promise resolved value!!</span>

<span class="hljs-comment">//📌 Till now we have been using Promise.then/.catch to handle promise.</span>
<span class="hljs-comment">// Now let's see how async await can help us and how it is different</span>

<span class="hljs-comment">// The rule is we have to use keyword await in front of promise.</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">await</span> p;
  <span class="hljs-built_in">console</span>.log(val);
}
handlePromise(); <span class="hljs-comment">// Promise resolved value!!</span></code></pre>

<p>📌 <code>await</code> কেবলমাত্র <code>async</code> ফাংশনের ভেতরেই ব্যবহার করা যায়।</p>

<pre class="hljs"><code><span class="hljs-keyword">await</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}; <span class="hljs-comment">// Syntax error: await is only valid under async function.</span></code></pre>

<p>প্রশ্ন: কী জিনিস async-await কে বিশেষ করে তোলে?<br>উত্তর: একটা উদাহরণ দিয়ে বোঝাই যেখানে async-await আর .then/.catch তুলনা করব। এজন্য আমরা আমাদের promise <code>p</code> একটু পরিবর্তন করব।</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"Promise resolved value!!"</span>);
  }, <span class="hljs-number">3000</span>);
});

<span class="hljs-comment">// Let's now compare with some modification:</span>

<span class="hljs-comment">// 📌 Promise.then/.catch way</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// JS engine will not wait for promise to be resolved</span>
  p.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(res));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello There!"</span>);
}

getData(); <span class="hljs-comment">// First `Hello There!` would be printed and then after 3 secs 'Promise resolved value!!' will be printed.</span>
<span class="hljs-comment">// Above happened as Javascript wait for none, so it will register this promise and take this callback function and register separately then js will move on and execute the following console and later once promise is resolved, following console will be printed.</span>

<span class="hljs-comment">//❓ Problem: Normally one used to get confused that JS will wait for promise to be resolved before executing following lines.</span>

<span class="hljs-comment">// 📌 async-wait way:</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// JS Engine will waiting for promise to resolve.</span>
  <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">await</span> p;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello There!"</span>);
  <span class="hljs-built_in">console</span>.log(val);
}
handlePromise(); <span class="hljs-comment">// This time `Hello There!` won't be printed immediately instead after 3 secs `Hello There!` will be printed followed by 'Promise resolved value!!'</span>
<span class="hljs-comment">// 💡 So basically code was waiting at `await` line to get the promise resolve before moving on to next line.</span>

<span class="hljs-comment">// Above is the major difference between Promise.then/.catch vs async-await</span>

<span class="hljs-comment">//🤓 Let's brainstorm more around async-await</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hi"</span>);
  <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">await</span> p;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello There!"</span>);
  <span class="hljs-built_in">console</span>.log(val);

  <span class="hljs-keyword">const</span> val2 = <span class="hljs-keyword">await</span> p;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello There! 2"</span>);
  <span class="hljs-built_in">console</span>.log(val2);
}
handlePromise();
<span class="hljs-comment">// In above code example, will our program wait for 2 time or will it execute parallely.</span>
<span class="hljs-comment">//📌 `Hi` printed instantly -&gt; now code will wait for 3 secs -&gt; After 3 secs both promises will be resolved so ('Hello There!' 'Promise resolved value!!' 'Hello There! 2' 'Promise resolved value!!') will get printed immediately.</span>

<span class="hljs-comment">// Let's create one promise and then resolve two different promise.</span>
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"Promise resolved value by p2!!"</span>);
  }, <span class="hljs-number">2000</span>);
});

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hi"</span>);
  <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">await</span> p;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello There!"</span>);
  <span class="hljs-built_in">console</span>.log(val);

  <span class="hljs-keyword">const</span> val2 = <span class="hljs-keyword">await</span> p2;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello There! 2"</span>);
  <span class="hljs-built_in">console</span>.log(val2);
}
handlePromise();
<span class="hljs-comment">// 📌 `Hi` printed instantly -&gt; now code will wait for 3 secs -&gt; After 3 secs both promises will be resolved so ('Hello There!' 'Promise resolved value!!' 'Hello There! 2' 'Promise resolved value by p2!!') will get printed immediately. So even though `p2` was resolved after 2 secs it had to wait for `p` to get resolved</span>

<span class="hljs-comment">// Now let's reverse the order execution of promise and observe response.</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hi"</span>);
  <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">await</span> p2;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello There!"</span>);
  <span class="hljs-built_in">console</span>.log(val);

  <span class="hljs-keyword">const</span> val2 = <span class="hljs-keyword">await</span> p;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello There! 2"</span>);
  <span class="hljs-built_in">console</span>.log(val2);
}
handlePromise();
<span class="hljs-comment">// 📌 `Hi` printed instantly -&gt; now code will wait for 2 secs -&gt; After 2 secs ('Hello There!' 'Promise resolved value by p2!!') will get printed and in the subsequent second i.e. after 3 secs ('Hello There! 2' 'Promise resolved value!!') will get printed</span></code></pre>

<p>প্রশ্ন: আসলে কি প্রোগ্রাম অপেক্ষা করছে নাকি ভেতরে অন্য কিছু হচ্ছে?<br>উত্তর: যেমন আমরা জানি, সময়, জোয়ার আর জাভাস্ক্রিপ্ট কারো জন্য অপেক্ষা করে না 😄। এখানে মনে হয় JS অপেক্ষা করছে কিন্তু আসলে JS engine অপেক্ষা করছে না। call stack ব্লক হয়নি, নাহলে পেজ ফ্রিজ হয়ে যেত। JS আসলে execution suspend করছে promise resolve না হওয়া পর্যন্ত।</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"Promise resolved value by p1!!"</span>);
  }, <span class="hljs-number">5000</span>);
});

<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"Promise resolved value by p2!!"</span>);
  }, <span class="hljs-number">10000</span>);
});

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hi"</span>);
  <span class="hljs-keyword">debugger</span>;
  <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">await</span> p1;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello There!"</span>);
  <span class="hljs-keyword">debugger</span>;
  <span class="hljs-built_in">console</span>.log(val);

  <span class="hljs-keyword">const</span> val2 = <span class="hljs-keyword">await</span> p2;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello There! 2"</span>);
  <span class="hljs-keyword">debugger</span>;
  <span class="hljs-built_in">console</span>.log(val2);
}
handlePromise();
<span class="hljs-comment">// When this function is executed, it will go line by line as JS is synchronous single threaded language. Lets observe what is happening under call-stack. Above you can see we have set the break-points.</span>

<span class="hljs-comment">// call stack flow -&gt; handlePromise() is pushed -&gt; It will log `Hi` to console -&gt; Next it sees we have await where promise is suppose to be resolved -&gt; So will it wait for promise to resolve and block call stack? No -&gt; thus handlePromise() execution get suspended and moved out of call stack -&gt; So when JS sees await keyword it suspend the execution of function till promise is resolved -&gt; So `p` will get resolved after 5 secs so handlePromise() will be pushed to call-stack again after 5 secs. -&gt; But this time it will start executing from where it had left. -&gt; Now it will log 'Hello There!' and 'Promise resolved value!!' -&gt; then it will check whether `p2` is resolved or not -&gt; It will find since `p2` will take 10 secs to resolve so the same above process will repeat -&gt; execution will be suspended until promise is resolved.</span>

<span class="hljs-comment">// 📌 Thus JS is not waiting, call stack is not getting blocked.</span>

<span class="hljs-comment">// Moreover in above scenario what if p1 would be taking 10 secs and p2 5 secs -&gt; even though p2 got resolved earlier but JS is synchronous single threaded language so it will first wait for p1 to be resolved and then will immediately execute all.</span></code></pre>

<h3 id="real-world-example-of-asyncawait"><a class="header-link" href="#real-world-example-of-asyncawait"></a>বাস্তব উদাহরণ: async/await</h3>

<pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// fetch() =&gt; Response Object which as body as Readable stream =&gt; Response.json() is also a promise which when resolved =&gt; value</span>
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">"https://api.github.com/users/alok722"</span>);
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> data.json();
  <span class="hljs-built_in">console</span>.log(res);
}
handlePromise();</code></pre>

<h3 id="error-handling"><a class="header-link" href="#error-handling"></a>Error হ্যান্ডলিং</h3>
<p>Promise ব্যবহারের সময় আমরা সাধারণত .catch ব্যবহার করতাম Error ধরতে। এখন <code>async-await</code> এ আমরা <code>try-catch</code> ব্লক ব্যবহার করব Error হ্যান্ডল করার জন্য।</p>

<pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">"https://api.github.com/users/alok722"</span>);
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> data.json();
    <span class="hljs-built_in">console</span>.log(res);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-built_in">console</span>.log(err);
  }
}
handlePromise();

<span class="hljs-comment">// In above whenever any error will occur the execution will move to catch block. One could try above with bad url which will result in error.</span>

<span class="hljs-comment">// Other way of handling error:</span>
handlePromise().catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(err)); <span class="hljs-comment">// this will work as handlePromise will return error promise in case of failure.</span></code></pre>

<h3 id="async-await-vs-promisethencatch"><a class="header-link" href="#async-await-vs-promisethencatch"></a>Async await বনাম Promise.then/.catch</h3>
<p>কোনটা ব্যবহার করা উচিত? <code>async-await</code> আসলে promise-এর চারপাশে syntactic sugar মাত্র। ভেতরে ভেতরে <code>async-await</code> আসলে promise-ই। তবে <code>async-await</code> কোডকে বেশি readable করে এবং Promise chaining-এর মত সমস্যাগুলো সমাধান করে। তাই আধুনিক কোডে <code>async-await</code> ব্যবহার করাই ভালো।</p>
<hr>

<p>ইউটিউবে সরাসরি দেখুন নিচে:</p>
<p><a href="https://www.youtube.com/watch?v=6nv3qy3oNkc&list=PLlasXeu85E9eWOpw9jxHOQyGMRiBZ60aX&index=4&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/6nv3qy3oNkc/0.jpg" width="750"
alt="async-await in Javascript Youtube Link"/></a></p>
<br>
<hr>

<h1 id="episode-24--promise-apis-all-allsettled-race-any--interview-questions-🔥"><a class="header-link" href="#episode-24--promise-apis-all-allsettled-race-any--interview-questions-🔥"></a>Episode 24 : Promise APIs (all, allSettled, race, any) + Interview Questions 🔥</h1>
<h3 id="-2"><a class="header-link" href="#-2"></a></h3>
<p>৪টি Promise API যা বেশি ব্যবহৃত হয়:</p>
<ul class="list">
<li>Promise.all()</li>
<li>Promise.allSettled()</li>
<li>Promise.race()</li>
<li>Promise.any()</li>
</ul>
<p>💡 Promise না জেনে async/await ব্যবহার করা যায় না!</p>
<h3 id="promiseall"><a class="header-link" href="#promiseall"></a>Promise.all()</h3>
<blockquote>
<p>Promise হলো এমন একটি placeholder যেটি ভবিষ্যতে কোনো একটি ভ্যালু পাবে। Promise asynchronous কাজগুলো হ্যান্ডেল করতে সাহায্য করে। JavaScript এ <code>Promise.all(promisesArrayOrIterable)</code> নামের হেল্পার ফাংশন আছে যেটি একসাথে অনেকগুলো promise parallel এ চালাতে পারে এবং শেষে সবার রেজাল্ট একটি অ্যারেতে রিটার্ন করে।</p>
</blockquote>
<p>প্রশ্ন: কোন পরিস্থিতিতে আমরা এই API ব্যবহার করব?<br>উত্তর: ধরো, তোমাকে একসাথে একাধিক API কল করতে হবে এবং সবগুলোর রেজাল্ট দরকার, তখন Promise.all কাজে লাগবে। এটি একই সাথে একাধিক promise হ্যান্ডেল করতে ব্যবহৃত হয়।</p>
<p>Promise.all([p1, p2, p3]) → ধরো আমরা ৩টি API কল করছি। ধরে নাও <strong>p1</strong> শেষ হতে <strong>৩ সেকেন্ড</strong>, <strong>p2</strong> শেষ হতে <strong>১ সেকেন্ড</strong>, <strong>p3</strong> শেষ হতে <strong>২ সেকেন্ড</strong> লাগছে।</p>
<p>প্রথম ক্ষেত্রে ধরা যাক ৩টি promise-ই সফল হয়েছে। তখন Promise.all <strong>৩ সেকেন্ড</strong> নেবে এবং আউটপুট দেবে [val1, val2, val3]। সবগুলো শেষ না হওয়া পর্যন্ত অপেক্ষা করবে, তারপর অ্যারের ভেতরে সব রেজাল্ট রিটার্ন করবে।</p>
<p>যদি কোনো একটি promise reject হয়, যেমন: Promise.all([p1, p2, p3]) → এবার p2 এক সেকেন্ড পর reject হলো। তখন Promise.all সঙ্গে সঙ্গেই সেই এরর throw করবে, অন্যগুলোর জন্য অপেক্ষা করবে না। তবে p1 এবং p3 বাতিল হবে না, সেগুলো তাদের মতো চলতে থাকবে। Promise.all শুধু error-টাই রিটার্ন করবে।</p>
<p>💡 সারকথা: <code>Promise.all()</code> সব promise resolve হওয়া পর্যন্ত অপেক্ষা করে এবং তাদের রেজাল্ট একটি অ্যারেতে রিটার্ন করে। যদি কোনো একটি promise reject হয়, তাহলে প্রথম reject হওয়া promise-এর error রিটার্ন করে।</p>

<h3 id="promiseallsettled"><a class="header-link" href="#promiseallsettled"></a>Promise.allSettled()</h3>
<blockquote>
<p><code>Promise.allSettled()</code> এমন একটি মেথড যা সব promise settle (resolve বা reject) না হওয়া পর্যন্ত অপেক্ষা করে এবং শেষে সবগুলোর রেজাল্ট একটি অ্যারে আকারে রিটার্ন করে।</p>
</blockquote>
<p>Promise.allSettled([p1, p2, p3]) → আগের মতোই ধরো ৩টি API কল হলো। <strong>p1</strong> ৩ সেকেন্ড, <strong>p2</strong> ১ সেকেন্ড, <strong>p3</strong> ২ সেকেন্ড।</p>
<p>যদি সবগুলো সফল হয়, তাহলে Promise.allSettled <strong>৩ সেকেন্ড</strong> পর [val1, val2, val3] আউটপুট দেবে।</p>
<p>যদি কোনো একটি reject হয়, যেমন p2 → তবুও Promise.allSettled ৩ সেকেন্ড পর্যন্ত অপেক্ষা করবে। তখন আউটপুট হবে [val1, err, val3]।</p>
<p>💡 Promise.all() → দ্রুত fail করে<br>💡 Promise.allSettled() → সব settle না হওয়া পর্যন্ত অপেক্ষা করে, তারপর সামগ্রিক ফলাফল দেয়</p>

<h3 id="promiserace"><a class="header-link" href="#promiserace"></a>Promise.race()</h3>
<blockquote>
<p><code>Promise.race()</code> একটি promise-এর লিস্ট নেয় এবং যেই promise সবার আগে resolve বা reject হবে, সেই রেজাল্ট-টাই রিটার্ন করবে। নামের মতোই, এগুলো দৌড়ায় এবং প্রথমে যেটি শেষ হয় সেটিই বিজয়ী।</p>
</blockquote>
<p>Promise.race([p1, p2, p3]) → ধরো একই API কলের example। যদি p2 ১ সেকেন্ডে শেষ হয়, তাহলে এটি হবে আউটপুট। সফল হলে success রিটার্ন করবে, ব্যর্থ হলে error।</p>

<h3 id="promiseany"><a class="header-link" href="#promiseany"></a>Promise.any()</h3>
<blockquote>
<p><code>Promise.any()</code> একটি promise-এর লিস্ট নেয় এবং প্রথম যেটি সফল (fulfilled) হয়, সেটির রেজাল্ট রিটার্ন করে।</p>
</blockquote>
<p>Promise.any([p1, p2, p3]) → আগের example মতো ধরো। p2 যদি ব্যর্থ হয়, তাতে কিছু আসে যায় না। প্রথম সফল promise পাওয়া মাত্র সেটি রেজাল্ট হবে।</p>
<p>❓ তবে যদি সবগুলো ব্যর্থ হয়, তখন এটি একটি AggregateError রিটার্ন করবে [err1, err2, err3] আকারে।</p>

<h2 id="code-examples"><a class="header-link" href="#code-examples"></a>Code Examples:</h2>
<h3 id="promiseall-1"><a class="header-link" href="#promiseall-1"></a>Promise.all()</h3>

<pre class="hljs"><code><span class="hljs-comment">// 📌 First Scenario</span>

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P1 Success"</span>);
  }, <span class="hljs-number">3000</span>);
});
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P2 Success"</span>);
  }, <span class="hljs-number">1000</span>);
});
<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P3 Success"</span>);
  }, <span class="hljs-number">2000</span>);
});

<span class="hljs-built_in">Promise</span>.all([p1, p2, p3]).then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(results); <span class="hljs-comment">// ['P1 Success', 'P2 Success', 'P3 Success'] -&gt; took 3 secs</span>
});</code></pre>

<pre class="hljs"><code><span class="hljs-comment">// 📌 Second Scenario</span>

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P1 Success"</span>);
  }, <span class="hljs-number">3000</span>);
});
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    reject(<span class="hljs-string">"P2 Fail"</span>);
  }, <span class="hljs-number">1000</span>);
});
<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P3 Success"</span>);
  }, <span class="hljs-number">2000</span>);
});

<span class="hljs-built_in">Promise</span>.all([p1, p2, p3])
  .then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(results))
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(err)); <span class="hljs-comment">// throws error after 1 sec i.e. 'P2 Fails'</span></code></pre>

<h3 id="promiseallsettled-1"><a class="header-link" href="#promiseallsettled-1"></a>Promise.allSettled()</h3>
<p>💡 এটি সব থেকে নিরাপদ Promise API।</p>

<pre class="hljs"><code><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P1 Success"</span>);
  }, <span class="hljs-number">3000</span>);
});
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P2 Success"</span>);
  }, <span class="hljs-number">1000</span>);
});
<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    reject(<span class="hljs-string">"P3 Fail"</span>);
  }, <span class="hljs-number">2000</span>);
});

<span class="hljs-built_in">Promise</span>.allSettled([p1, p2, p3])
  .then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(results))
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(err));

<span class="hljs-comment">// Over here, it will wait for all promises to be either settled or rejected and then return,</span>
<span class="hljs-comment">/*
    [
      {status: 'fulfilled', value: 'P1 Success'},
      {status: 'fulfilled', value: 'P2 Success'},
      {status: 'rejected', reason: 'P3 Fail'}
    ]
  */</span></code></pre>

<h3 id="promiserace-1"><a class="header-link" href="#promiserace-1"></a>Promise.race()</h3>

<pre class="hljs"><code><span class="hljs-comment">// 📌 First Scenario</span>

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P1 Success"</span>);
  }, <span class="hljs-number">3000</span>);
});
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P2 Success"</span>);
  }, <span class="hljs-number">1000</span>);
});
<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    reject(<span class="hljs-string">"P3 Fail"</span>);
  }, <span class="hljs-number">2000</span>);
});

<span class="hljs-built_in">Promise</span>.race([p1, p2, p3])
  .then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(results))
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(err));

<span class="hljs-comment">// It will return as soon as first promise is resolved or rejected.</span>
<span class="hljs-comment">// In above example O/P: "P2 Success"</span></code></pre>

<pre class="hljs"><code><span class="hljs-comment">// 📌 Second Scenario</span>

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P1 Success"</span>);
  }, <span class="hljs-number">3000</span>);
});
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P2 Success"</span>);
  }, <span class="hljs-number">5000</span>);
});
<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    reject(<span class="hljs-string">"P3 Fail"</span>);
  }, <span class="hljs-number">2000</span>);
});

<span class="hljs-built_in">Promise</span>.race([p1, p2, p3])
  .then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(results))
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(err));

<span class="hljs-comment">//After 2 secs O/P: "P3 Fail"</span></code></pre>

<p>📌 নোট:</p>
<ul class="list">
<li>Promise settle মানে হলো রেজাল্ট পাওয়া।</li>
</ul>
<ol class="list">
<li>resolve / success / fulfilled</li>
<li>reject / failure / rejected</li>
</ol>

<h3 id="promiseany-1"><a class="header-link" href="#promiseany-1"></a>Promise.any()</h3>
<pre class="hljs"><code><span class="hljs-comment">// 📌 First Scenario</span>

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P1 Success"</span>);
  }, <span class="hljs-number">3000</span>);
});
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P2 Success"</span>);
  }, <span class="hljs-number">5000</span>);
});
<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    reject(<span class="hljs-string">"P3 Fail"</span>);
  }, <span class="hljs-number">2000</span>);
});

<span class="hljs-built_in">Promise</span>.any([p1, p2, p3])
  .then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(results))
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(err));

<span class="hljs-comment">// It will wait for first settled **success**</span>
<span class="hljs-comment">// In above, p3 will settled first, but since it is rejected, so it will wait further so at 3rd second it will print "P1 Success"</span></code></pre>

<pre class="hljs"><code><span class="hljs-comment">// 📌 Second Scenario</span>

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    reject(<span class="hljs-string">"P1 Fail"</span>);
  }, <span class="hljs-number">3000</span>);
});
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    resolve(<span class="hljs-string">"P2 Success"</span>);
  }, <span class="hljs-number">5000</span>);
});
<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    reject(<span class="hljs-string">"P3 Fail"</span>);
  }, <span class="hljs-number">2000</span>);
});

<span class="hljs-built_in">Promise</span>.any([p1, p2, p3])
  .then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(results))
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(err));

<span class="hljs-comment">// After 5 secs: 'P2 Success'</span></code></pre>

<pre class="hljs"><code><span class="hljs-comment">// 📌 Third Scenario</span>

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    reject(<span class="hljs-string">"P1 Fail"</span>);
  }, <span class="hljs-number">3000</span>);
});
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    reject(<span class="hljs-string">"P2 Fail"</span>);
  }, <span class="hljs-number">5000</span>);
});
<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    reject(<span class="hljs-string">"P3 Fail"</span>);
  }, <span class="hljs-number">2000</span>);
});

<span class="hljs-built_in">Promise</span>.any([p1, p2, p3])
  .then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(results))
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(err);
    <span class="hljs-built_in">console</span>.error(err.errors); <span class="hljs-comment">// ['P1 Fail', 'P2 Fail', 'P3 Fail']</span>
  });

<span class="hljs-comment">// Since all are rejected, so it will give "aggregate error" as output</span>
<span class="hljs-comment">// AggregateError: All promises were rejected</span>
<span class="hljs-comment">// To get AggregateError array you need to write "err.errors"</span></code></pre>

<h3 id="summary"><a class="header-link" href="#summary"></a>Summary</h3>
<p>Promise ক্লাসের ৬টি static মেথড আছে:</p>
<blockquote>
<p>Promise.all(promises) – সবগুলো resolve না হওয়া পর্যন্ত অপেক্ষা করে এবং রেজাল্ট অ্যারে আকারে রিটার্ন করে। যদি কোনো একটি reject হয়, তাহলে error রিটার্ন করে।</p>
</blockquote>
<blockquote>
<p>Promise.allSettled(promises) – সবগুলো settle হওয়া পর্যন্ত অপেক্ষা করে এবং রেজাল্ট status সহ রিটার্ন করে।</p>
</blockquote>
<blockquote>
<p>Promise.race(promises) – প্রথম যে promise settle হয়, তার রেজাল্ট রিটার্ন করে।</p>
</blockquote>
<blockquote>
<p>Promise.any(promises) – প্রথম যে promise সফল হয়, তার রেজাল্ট রিটার্ন করে। সবগুলো reject হলে AggregateError রিটার্ন করে।</p>
</blockquote>
<blockquote>
<p>Promise.resolve(value) – প্রদত্ত ভ্যালু সহ resolve promise তৈরি করে।</p>
</blockquote>
<blockquote>
<p>Promise.reject(error) – প্রদত্ত error সহ reject promise তৈরি করে।</p>
</blockquote>
<p>👉 এর মধ্যে <code>Promise.all</code> সবচেয়ে বেশি ব্যবহৃত হয়।</p>
<hr>

<p>ইউটিউবে সরাসরি দেখুন:</p>
<p><a href="https://www.youtube.com/watch?v=DlTVt1rZjIo&list=PLlasXeu85E9eWOpw9jxHOQyGMRiBZ60aX&index=4&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/DlTVt1rZjIo/0.jpg" width="750"
alt="promise-apis in Javascript Youtube Link"/></a></p>
<br>

<hr>

<h1 id="episode-25--this-keyword-in-javascript"><a class="header-link" href="#episode-25--this-keyword-in-javascript"></a>Episode 25 : <code>this</code> keyword in JavaScript</h1>
<h3 id="-3"><a class="header-link" href="#-3"></a></h3>
<blockquote>
<p>JavaScript-এ <code>this</code> কীওয়ার্ড সবসময় একটি অবজেক্টকে নির্দেশ করে। কোন অবজেক্টকে নির্দেশ করবে সেটা নির্ভর করে <code>this</code> কীভাবে invoke (ব্যবহার বা কল) করা হচ্ছে তার উপর।</p>
</blockquote>

<h2 id="this-in-global-space"><a class="header-link" href="#this-in-global-space"></a><code>this</code> in global space</h2>
<p>যে কোনো কিছু যদি গ্লোবালি ডিফাইন করা হয়, সেটি global space-এ থাকে।</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// refers to global object i.e. window in case of browser</span>
<span class="hljs-comment">// 💡 global object differs based on runtime environment,</span></code></pre>

<h2 id="this-inside-a-function"><a class="header-link" href="#this-inside-a-function"></a><code>this</code> inside a function</h2>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// the below value depends on strict/non-strict mode</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);
  <span class="hljs-comment">// in strict mode - undefined</span>
  <span class="hljs-comment">// in non-strict mode - refers to global window object</span>
}
x();
<span class="hljs-comment">// 💡 Notes:</span>

<span class="hljs-comment">// On the first go feels like `this` keyword in global space and inside function behaves same but in reality it's different.</span>

<span class="hljs-comment">// The moment you make JS run in strict mode by using: "use strict" at the top, `this` keyword inside function returns `undefined` whereas global space will still refers to global window object</span></code></pre>

<p><code>this substitution</code> → নিয়ম অনুযায়ী, যদি <code>this</code> এর ভ্যালু <code>null/undefined</code> হয়, তবে non-strict mode-এ এটি global object দ্বারা রিপ্লেস হয়ে যায়। এজন্যই non-strict mode-এ <code>this</code> গ্লোবাল window object নির্দেশ করে, কিন্তু strict mode-এ <code>undefined</code> থাকে।</p>

<p>💡 সারসংক্ষেপ: function-এর ভেতরে <code>this</code> এর ভ্যালু আসলে <code>undefined</code>, তবে non-strict mode-এ substitution rule এর কারণে এটি global window object হয়ে যায়। strict mode-এ এটি সবসময় <code>undefined</code>।</p>

<p><code>this</code> এর ভ্যালু নির্ভর করে function কিভাবে কল করা হচ্ছে তার উপর। উদাহরণ:</p>
<p>Strict mode-এ:</p>
<pre class="hljs"><code>x(); <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">window</span>.x(); <span class="hljs-comment">// global window object</span></code></pre>

<h2 id="this-inside-a-objects-method"><a class="header-link" href="#this-inside-a-objects-method"></a><code>this</code> inside a object's method</h2>
<pre class="hljs"><code><span class="hljs-comment">// `x` key below is a method as per terminology</span>
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">x</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// {a: 10, x: f()}</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a); <span class="hljs-comment">// 10</span>
  },
};
obj.x(); <span class="hljs-comment">// value of `this` is referring to current object i.e. `obj`</span></code></pre>

<h2 id="call-apply--bind-methods"><a class="header-link" href="#call-apply--bind-methods"></a><code>call</code>, <code>apply</code> &amp; <code>bind</code> methods</h2>
<blockquote>
<p>call, apply এবং bind মেথড সম্পর্কে বিস্তারিত জানতে <a href="https://www.youtube.com/watch?v=75W8UPQ5l7k&ab_channel=AkshaySaini">এখানে দেখো</a>।</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">const</span> student = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Alok"</span>,
  <span class="hljs-attr">printName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
  },
};
student.printName(); <span class="hljs-comment">// Alok</span>

<span class="hljs-keyword">const</span> student2 = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Kajal"</span>,
};
student2.printName(); <span class="hljs-comment">// throw error</span>

<span class="hljs-comment">// ❓ how to re-use printName method from `student` object</span>
student.printName.call(student2); <span class="hljs-comment">// Kajal</span>
<span class="hljs-comment">// Above `call` method is taking the value of `this` keyword</span>
<span class="hljs-comment">// So, Inside `printName` method value of `this` is now `student2` object</span>

<span class="hljs-comment">// So, call, bind and apply is used to set the value of this keyword.</span></code></pre>

<h2 id="this-inside-arrow-function"><a class="header-link" href="#this-inside-arrow-function"></a><code>this</code> inside arrow function</h2>
<p>Arrow function-এর নিজস্ব <code>this</code> নেই, তারা enclosing lexical context থেকে <code>this</code> এর ভ্যালু নেয়।</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">x</span>: <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// window object</span>
    <span class="hljs-comment">// Above the value of `this` won't be obj anymore instead it will be enclosing lexical context i.e. window object in current scenario.</span>
  },
};
obj.x();

<span class="hljs-keyword">const</span> obj2 = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">x</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> y = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);
      <span class="hljs-comment">// Above the value of `this` will be obj2 as function y's enclosing lexical context is function `x`.</span>
    };
    y();
  },
};
obj2.x();</code></pre>

<h2 id="this-inside-dom"><a class="header-link" href="#this-inside-dom"></a><code>this</code> inside DOM</h2>
<blockquote>
<p>DOM element-এর context-এ <code>this</code> সেই HTML element-কে নির্দেশ করে।</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"alert(this)"</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-comment">&lt;!-- [object HTMLButtonElement] Button element --&gt;</span></code></pre>
<hr>

<p>ইউটিউবে সরাসরি দেখুন:</p>
<p><a href="https://www.youtube.com/watch?v=9T4z98JcHR0&list=PLlasXeu85E9eWOpw9jxHOQyGMRiBZ60aX&index=4&ab_channel=AkshaySaini" target="_blank"><img src="https://img.youtube.com/vi/9T4z98JcHR0/0.jpg" width="750"
alt="this keyword in Javascript Youtube Link"/></a></p>
<p>To Be Continued...</p>
</body>
</html>